Review this code base file by file , line by line, to fully understand the code base - identify all features, functions, utilities, etc.
Identify any issues, gaps, inconsistencies, etc. 
Additionally identify potential enhancements, including architectural changes, refactoring, etc.
Skip adding unit/integration tests - that is handled externally.
Identify the modern, best approach for what we're trying to accomplish; prefer using the latest stable versions of libraries and frameworks.
After you have properly reviewed the code base and mapped out the necessary changes, write out a detailed plan for my developer on exactly what to change in our current code base.

# Full project repository tree

# obsidian-mcp-server - Directory Structure

Generated on: 2025-08-22 09:27:37

```
obsidian-mcp-server
├── .clinerules
│   └── clinerules.md
├── .github
│   ├── workflows
│   │   └── publish.yml
│   └── FUNDING.yml
├── docs
│   ├── obsidian-api
│   │   └── obsidian_rest_api_spec.yaml
│   ├── devdocs.md
│   ├── obsidian_mcp_tools_spec.md
│   └── tree.md
├── scripts
│   ├── clean.ts
│   ├── devdocs.ts
│   ├── fetch-openapi-spec.ts
│   ├── make-executable.ts
│   └── tree.ts
├── src
│   ├── config
│   │   └── index.ts
│   ├── mcp-server
│   │   ├── tools
│   │   │   ├── obsidianDeleteNoteTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianGlobalSearchTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianListNotesTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianManageFrontmatterTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianManageTagsTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianReadNoteTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianSearchReplaceTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   ├── obsidianUpdateNoteTool
│   │   │   │   ├── index.ts
│   │   │   │   ├── logic.ts
│   │   │   │   └── registration.ts
│   │   │   └── schemas
│   │   │       └── jsonSchema.ts
│   │   ├── transports
│   │   │   ├── auth
│   │   │   │   ├── lib
│   │   │   │   ├── strategies
│   │   │   │   │   ├── authStrategy.ts
│   │   │   │   │   ├── jwtStrategy.ts
│   │   │   │   │   └── oauthStrategy.ts
│   │   │   │   ├── authFactory.ts
│   │   │   │   ├── authMiddleware.ts
│   │   │   │   └── index.ts
│   │   │   ├── core
│   │   │   │   ├── baseTransportManager.ts
│   │   │   │   ├── honoNodeBridge.ts
│   │   │   │   ├── statefulTransportManager.ts
│   │   │   │   ├── statelessTransportManager.ts
│   │   │   │   └── transportTypes.ts
│   │   │   ├── http
│   │   │   │   ├── httpErrorHandler.ts
│   │   │   │   ├── httpTransport.ts
│   │   │   │   ├── httpTypes.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── mcpTransportMiddleware.ts
│   │   │   └── stdio
│   │   │       ├── index.ts
│   │   │       └── stdioTransport.ts
│   │   └── server.ts
│   ├── services
│   │   └── obsidianRestAPI
│   │       ├── utils
│   │       │   ├── apiErrors.ts
│   │       │   ├── formatting.ts
│   │       │   ├── index.ts
│   │       │   ├── pathEncoding.ts
│   │       │   └── pathResolver.ts
│   │       ├── vaultCache
│   │       │   ├── index.ts
│   │       │   └── service.ts
│   │       ├── generated-types.ts
│   │       ├── index.ts
│   │       └── service.ts
│   ├── types-global
│   │   └── errors.ts
│   ├── utils
│   │   ├── internal
│   │   │   ├── asyncUtils.ts
│   │   │   ├── errorHandler.ts
│   │   │   ├── fetch.ts
│   │   │   ├── index.ts
│   │   │   ├── logger.ts
│   │   │   └── requestContext.ts
│   │   ├── metrics
│   │   │   ├── index.ts
│   │   │   └── tokenCounter.ts
│   │   ├── parsing
│   │   │   ├── dateParser.ts
│   │   │   ├── index.ts
│   │   │   └── jsonParser.ts
│   │   ├── security
│   │   │   ├── idGenerator.ts
│   │   │   ├── index.ts
│   │   │   ├── rateLimiter.ts
│   │   │   └── sanitization.ts
│   │   └── index.ts
│   └── index.ts
├── .gitignore
├── .ncurc.json
├── CHANGELOG.md
├── Dockerfile
├── env.json
├── LICENSE
├── mcp.json
├── package-lock.json
├── package.json
├── README.md
├── repomix.config.json
├── smithery.yaml
├── tsconfig.json
└── typedoc.json
```

_Note: This tree excludes files and directories matched by .gitignore and default patterns._


---

# Let's focus on the following section of our code base.

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-22T09:27:38.071Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
utils/
  apiErrors.ts
  formatting.ts
  index.ts
  pathEncoding.ts
  pathResolver.ts
vaultCache/
  index.ts
  service.ts
generated-types.ts
index.ts
service.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="utils/apiErrors.ts">
/**
 * @fileoverview Utilities for handling API errors.
 * @module src/services/obsidianRestAPI/utils/apiErrors
 */
import { RequestContext, logger } from "../../../utils/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";

export type FetchError =
  | {
      data?: any;
      error: string | object;
    }
  | {
      data?: any;
      error?: undefined;
    };

export function handleApiError(
  error: FetchError,
  context: RequestContext,
  operation: string,
): McpError {
  const errorMessage =
    typeof error.error === "string" ? error.error : JSON.stringify(error.error);
  logger.error(`Obsidian API Error during ${operation}: ${errorMessage}`, {
    ...context,
    apiError: error,
  });

  if (errorMessage.includes("Not Found")) {
    return new McpError(
      BaseErrorCode.NOT_FOUND,
      `File or resource not found in Obsidian during ${operation}.`,
      { ...context, originalError: error },
    );
  }

  return new McpError(
    BaseErrorCode.SERVICE_UNAVAILABLE,
    `An error occurred while communicating with the Obsidian API during ${operation}.`,
    { ...context, originalError: error },
  );
}
</file>

<file path="utils/formatting.ts">
/**
 * @fileoverview Utilities for formatting stats and timestamps.
 * @module src/services/obsidianRestAPI/utils/formatting
 */

import { format } from "date-fns";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { logger, RequestContext } from "../../../utils/internal/index.js";
import { countTokens } from "../../../utils/metrics/index.js";

const DEFAULT_TIMESTAMP_FORMAT = "hh:mm:ss a | MM-dd-yyyy";

export function formatTimestamp(
  timestampMs: number | undefined | null,
  context: RequestContext,
  formatString: string = DEFAULT_TIMESTAMP_FORMAT,
): string {
  const operation = "formatTimestamp";
  if (
    timestampMs === undefined ||
    timestampMs === null ||
    !Number.isFinite(timestampMs)
  ) {
    const errorMessage = `Invalid timestamp provided for formatting: ${timestampMs}`;
    logger.warning(errorMessage, { ...context, operation });
    throw new McpError(BaseErrorCode.VALIDATION_ERROR, errorMessage, {
      ...context,
      operation,
    });
  }

  try {
    const date = new Date(timestampMs);
    if (isNaN(date.getTime())) {
      const errorMessage = `Timestamp resulted in an invalid date: ${timestampMs}`;
      logger.warning(errorMessage, { ...context, operation });
      throw new McpError(BaseErrorCode.VALIDATION_ERROR, errorMessage, {
        ...context,
        operation,
      });
    }
    return format(date, formatString);
  } catch (error) {
    const errorMessage = `Failed to format timestamp ${timestampMs}: ${error instanceof Error ? error.message : String(error)}`;
    logger.error(errorMessage, error instanceof Error ? error : undefined, {
      ...context,
      operation,
    });
    throw new McpError(BaseErrorCode.INTERNAL_ERROR, errorMessage, {
      ...context,
      operation,
      originalError: error instanceof Error ? error.message : String(error),
    });
  }
}

export interface ObsidianStat {
  ctime: number;
  mtime: number;
  size: number;
}

export interface FormattedTimestamps {
  createdTime: string;
  modifiedTime: string;
}

export function formatStatTimestamps(
  stat: ObsidianStat | undefined | null,
  context: RequestContext,
): FormattedTimestamps {
  const operation = "formatStatTimestamps";
  if (!stat) {
    logger.debug(
      "Stat object is undefined or null, returning N/A for timestamps.",
      { ...context, operation },
    );
    return {
      createdTime: "N/A",
      modifiedTime: "N/A",
    };
  }
  try {
    return {
      createdTime: formatTimestamp(stat.ctime, context),
      modifiedTime: formatTimestamp(stat.mtime, context),
    };
  } catch (error) {
    logger.error(
      `Error formatting timestamps within formatStatTimestamps for ctime: ${stat.ctime}, mtime: ${stat.mtime}`,
      error instanceof Error ? error : undefined,
      { ...context, operation },
    );
    return {
      createdTime: "N/A",
      modifiedTime: "N/A",
    };
  }
}

export interface FormattedStatWithTokenCount extends FormattedTimestamps {
  tokenCountEstimate: number;
}

export async function createFormattedStatWithTokenCount(
  stat: ObsidianStat | null | undefined,
  content: string,
  context: RequestContext,
): Promise<FormattedStatWithTokenCount | null | undefined> {
  const operation = "createFormattedStatWithTokenCount";
  if (stat === null || stat === undefined) {
    logger.debug("Input stat is null or undefined, returning as is.", {
      ...context,
      operation,
    });
    return stat;
  }

  const formattedTimestamps = formatStatTimestamps(stat, context);
  let tokenCountEstimate = -1;

  if (content && content.trim().length > 0) {
    try {
      tokenCountEstimate = await countTokens(content, context);
    } catch (tokenError) {
      logger.warning(
        `Failed to count tokens for stat object. Error: ${tokenError instanceof Error ? tokenError.message : String(tokenError)}`,
        {
          ...context,
          operation,
          originalError:
            tokenError instanceof Error
              ? tokenError.message
              : String(tokenError),
        },
      );
    }
  } else {
    logger.debug(
      "Content is empty or whitespace-only, setting tokenCountEstimate to 0.",
      { ...context, operation },
    );
    tokenCountEstimate = 0;
  }

  return {
    createdTime: formattedTimestamps.createdTime,
    modifiedTime: formattedTimestamps.modifiedTime,
    tokenCountEstimate: tokenCountEstimate,
  };
}
</file>

<file path="utils/index.ts">
/**
 * @fileoverview Consolidated utilities for the Obsidian REST API service.
 * @module src/services/obsidianRestAPI/utils
 */

export * from "./apiErrors.js";
export * from "./pathEncoding.js";
export * from "./formatting.js";
</file>

<file path="utils/pathEncoding.ts">
/**
 * @fileoverview Utilities for encoding paths for the Obsidian API.
 * @module src/services/obsidianRestAPI/utils/pathEncoding
 */

export function encodeVaultPath(filePath: string): string {
  if (!filePath) return "";
  return filePath
    .replace(/^\/+|\/+$/g, "")
    .split("/")
    .map(encodeURIComponent)
    .join("/");
}

export function encodeDirectoryPath(dirPath: string): string {
  const trimmedPath = dirPath.trim();
  if (trimmedPath === "" || trimmedPath === "/") {
    return "";
  }
  return trimmedPath
    .replace(/^\/+|\/+$/g, "")
    .split("/")
    .map(encodeURIComponent)
    .join("/");
}
</file>

<file path="utils/pathResolver.ts">
/**
 * @fileoverview Provides a utility for resolving file paths within the Obsidian vault,
 * supporting case-insensitive fallbacks.
 * @module src/services/obsidianRestAPI/utils/pathResolver
 */
import path from "node:path";
import { RequestContext, logger } from "../../../utils/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { components } from "../generated-types.js";

type NoteStat = components["schemas"]["NoteJson"]["stat"];
type MetadataFetcher = (
  filePath: string,
  context: RequestContext,
) => Promise<NoteStat | null>;
type FileLister = (
  dirPath: string,
  context: RequestContext,
) => Promise<string[]>;

/**
 * Resolves a vault-relative file path with a case-insensitive fallback.
 * It first attempts a direct, case-sensitive match. If that fails, it searches
 * the file's directory for a case-insensitive match.
 *
 * @param filePath The vault-relative path to resolve.
 * @param context The request context for logging and tracing.
 * @param metadataFetcher A function to fetch file metadata.
 * @param fileLister A function to list files in a directory.
 * @returns A promise that resolves with the correct, case-sensitive file path.
 * @throws {McpError} If the path is not found, or if there are ambiguous matches.
 */
export async function resolveVaultPath(
  filePath: string,
  context: RequestContext,
  metadataFetcher: MetadataFetcher,
  fileLister: FileLister,
): Promise<string> {
  // 1. Try a direct, case-sensitive check first for performance.
  const metadata = await metadataFetcher(filePath, context);
  if (metadata) {
    return filePath;
  }

  // 2. If not found, attempt a case-insensitive fallback.
  logger.info(
    `Path '${filePath}' not found, attempting case-insensitive fallback.`,
    context,
  );
  const dirname = path.posix.dirname(filePath);
  const filenameLower = path.posix.basename(filePath).toLowerCase();
  const dirToList = dirname === "." ? "/" : dirname;

  const filesInDir = await fileLister(dirToList, context);
  const matches = filesInDir.filter(
    (f: string) =>
      !f.endsWith("/") &&
      path.posix.basename(f).toLowerCase() === filenameLower,
  );

  if (matches.length === 1) {
    const matchedFile = matches[0];
    // listFiles returns the full path for files in subdirectories, but just the basename for files in the root.
    const finalPath =
      dirToList === "/"
        ? matchedFile
        : path.posix.join(dirname, path.posix.basename(matchedFile));
    logger.info(`Found case-insensitive match: '${finalPath}'`, context);
    return finalPath;
  }

  if (matches.length > 1) {
    throw new McpError(
      BaseErrorCode.CONFLICT,
      `Ambiguous case-insensitive matches for '${filePath}'. Found: [${matches.join(", ")}]`,
      context,
    );
  }

  throw new McpError(
    BaseErrorCode.NOT_FOUND,
    `Path not found: '${filePath}' (case-insensitive fallback also failed).`,
    context,
  );
}
</file>

<file path="vaultCache/index.ts">
/**
 * Barrel file for the VaultCacheService.
 */
export * from "./service.js";
</file>

<file path="vaultCache/service.ts">
/**
 * @module VaultCacheService
 * @description Service for building and managing an in-memory cache of Obsidian vault content.
 */

import path from "node:path";
import { config } from "../../../config/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import {
  logger,
  RequestContext,
  requestContextService,
  retryWithDelay,
} from "../../../utils/index.js";
import { ObsidianApi, ObsidianRestApiService } from "../index.js";

type NoteJson = ObsidianApi["schemas"]["NoteJson"];

interface CacheEntry {
  content: string;
  mtime: number; // Store modification time for date filtering
  // Add other stats if needed, e.g., ctime, size
}

/**
 * Manages an in-memory cache of the Obsidian vault's file structure and metadata.
 *
 * __Is the cache safe and secure?__
 * Yes, the cache is safe and secure for its purpose within this application. Here's why:
 * 1. __In-Memory Storage:__ The cache exists only in the server's memory. It is not written to disk or transmitted over the network, so its attack surface is limited to the server process itself.
 * 2. __Local Data Source:__ The data populating the cache comes directly from your own Obsidian vault via the local REST API. It is not fetching data from external, untrusted sources.
 *
 * __Warning: High Memory Usage__
 * This service stores the entire content of every markdown file in the vault in memory. For users with very large vaults (e.g., many gigabytes of markdown files), this can lead to significant RAM consumption. If you experience high memory usage, consider disabling the cache via the `OBSIDIAN_ENABLE_CACHE` environment variable.
 */
export class VaultCacheService {
  private vaultContentCache: Map<string, CacheEntry> = new Map();
  private isCacheReady: boolean = false;
  private isBuilding: boolean = false;
  private obsidianService: ObsidianRestApiService;
  private refreshIntervalId: NodeJS.Timeout | null = null;

  constructor(obsidianService: ObsidianRestApiService) {
    this.obsidianService = obsidianService;
    logger.info(
      "VaultCacheService initialized.",
      requestContextService.createRequestContext({
        operation: "VaultCacheServiceInit",
      }),
    );
  }

  /**
   * Starts the periodic cache refresh mechanism.
   * The interval is controlled by the `OBSIDIAN_CACHE_REFRESH_INTERVAL_MIN` config setting.
   */
  public startPeriodicRefresh(): void {
    const refreshIntervalMs =
      config.obsidianCacheRefreshIntervalMin * 60 * 1000;
    if (this.refreshIntervalId) {
      logger.warning(
        "Periodic refresh is already running.",
        requestContextService.createRequestContext({
          operation: "startPeriodicRefresh",
        }),
      );
      return;
    }
    this.refreshIntervalId = setInterval(
      () => this.refreshCache(),
      refreshIntervalMs,
    );
    logger.info(
      `Vault cache periodic refresh scheduled every ${config.obsidianCacheRefreshIntervalMin} minutes.`,
      requestContextService.createRequestContext({
        operation: "startPeriodicRefresh",
      }),
    );
  }

  /**
   * Stops the periodic cache refresh mechanism.
   * Should be called during graceful shutdown.
   */
  public stopPeriodicRefresh(): void {
    const context = requestContextService.createRequestContext({
      operation: "stopPeriodicRefresh",
    });
    if (this.refreshIntervalId) {
      clearInterval(this.refreshIntervalId);
      this.refreshIntervalId = null;
      logger.info("Stopped periodic cache refresh.", context);
    } else {
      logger.info("Periodic cache refresh was not running.", context);
    }
  }

  /**
   * Checks if the cache has been successfully built.
   * @returns {boolean} True if the cache is ready, false otherwise.
   */
  public isReady(): boolean {
    return this.isCacheReady;
  }

  /**
   * Checks if the cache is currently being built.
   * @returns {boolean} True if the cache build is in progress, false otherwise.
   */
  public getIsBuilding(): boolean {
    return this.isBuilding;
  }

  /**
   * Returns the entire vault content cache.
   * Use with caution for large vaults due to potential memory usage.
   * @returns {ReadonlyMap<string, CacheEntry>} The cache map.
   */
  public getCache(): ReadonlyMap<string, CacheEntry> {
    // Return a readonly view or copy if mutation is a concern
    return this.vaultContentCache;
  }

  /**
   * Retrieves a specific entry from the cache.
   * @param {string} filePath - The vault-relative path of the file.
   * @returns {CacheEntry | undefined} The cache entry or undefined if not found.
   */
  public getEntry(filePath: string): CacheEntry | undefined {
    return this.vaultContentCache.get(filePath);
  }

  /**
   * Immediately fetches the latest data for a single file and updates its entry in the cache.
   * This is useful for ensuring cache consistency immediately after a file modification.
   * @param {string} filePath - The vault-relative path of the file to update.
   * @param {RequestContext} context - The request context for logging.
   */
  public async updateCacheForFile(
    filePath: string,
    context: RequestContext,
  ): Promise<void> {
    const opContext = { ...context, operation: "updateCacheForFile", filePath };
    logger.debug(`Proactively updating cache for file: ${filePath}`, opContext);
    try {
      const noteJson = await retryWithDelay(
        () =>
          this.obsidianService.getFileContent(
            filePath,
            "json",
            opContext,
          ) as Promise<NoteJson>,
        {
          operationName: "proactiveCacheUpdate",
          context: opContext,
          maxRetries: 3,
          delayMs: 300,
          shouldRetry: (err: unknown) =>
            err instanceof McpError &&
            (err.code === BaseErrorCode.NOT_FOUND ||
              err.code === BaseErrorCode.SERVICE_UNAVAILABLE),
        },
      );

      if (noteJson && noteJson.content && noteJson.stat) {
        this.vaultContentCache.set(filePath, {
          content: noteJson.content,
          mtime: noteJson.stat.mtime,
        });
        logger.info(`Proactively updated cache for: ${filePath}`, opContext);
      } else {
        logger.warning(
          `Proactive cache update for ${filePath} received invalid data, skipping update.`,
          opContext,
        );
      }
    } catch (error) {
      // If the file was deleted, a NOT_FOUND error is expected. We should remove it from the cache.
      if (error instanceof McpError && error.code === BaseErrorCode.NOT_FOUND) {
        if (this.vaultContentCache.has(filePath)) {
          this.vaultContentCache.delete(filePath);
          logger.info(
            `Proactively removed deleted file from cache: ${filePath}`,
            opContext,
          );
        }
      } else {
        logger.error(
          `Failed to proactively update cache for ${filePath}. Error: ${error instanceof Error ? error.message : String(error)}`,
          opContext,
        );
      }
    }
  }

  /**
   * Builds the in-memory cache by fetching all markdown files and their content.
   * This is intended to be run once at startup. Subsequent updates are handled by `refreshCache`.
   */
  public async buildVaultCache(): Promise<void> {
    const initialBuildContext = requestContextService.createRequestContext({
      operation: "buildVaultCache.initialCheck",
    });
    if (this.isBuilding) {
      logger.warning(
        "Cache build already in progress. Skipping.",
        initialBuildContext,
      );
      return;
    }
    if (this.isCacheReady) {
      logger.info("Cache already built. Skipping.", initialBuildContext);
      return;
    }

    await this.refreshCache(true); // Perform an initial, full build
  }

  /**
   * Refreshes the cache by comparing remote file modification times with cached ones.
   * Only fetches content for new or updated files.
   * @param isInitialBuild - If true, forces a full build and sets the cache readiness flag.
   */
  public async refreshCache(isInitialBuild = false): Promise<void> {
    const context = requestContextService.createRequestContext({
      operation: "refreshCache",
      isInitialBuild,
    });

    if (this.isBuilding) {
      logger.warning("Cache refresh already in progress. Skipping.", context);
      return;
    }

    this.isBuilding = true;
    if (isInitialBuild) {
      this.isCacheReady = false;
    }

    logger.info("Starting vault cache refresh process...", context);

    try {
      const startTime = Date.now();
      const remoteFiles = await this.listAllMarkdownFiles("/", context);
      const remoteFileSet = new Set(remoteFiles);
      const cachedFileSet = new Set(this.vaultContentCache.keys());

      let filesAdded = 0;
      let filesUpdated = 0;
      let filesRemoved = 0;

      // 1. Remove deleted files from cache
      for (const cachedFile of cachedFileSet) {
        if (!remoteFileSet.has(cachedFile)) {
          this.vaultContentCache.delete(cachedFile);
          filesRemoved++;
          logger.debug(`Removed deleted file from cache: ${cachedFile}`, {
            ...context,
            filePath: cachedFile,
          });
        }
      }

      // 2. Check for new or updated files
      for (const filePath of remoteFiles) {
        try {
          const fileMetadata = await this.obsidianService.getFileMetadata(
            filePath,
            context,
          );

          const cachedEntry = this.vaultContentCache.get(filePath);

          // Determine if an update is needed.
          // An update is needed if:
          // 1. The file is not in the cache.
          // 2. The file has valid metadata and is newer than the cached version.
          // 3. The file has NO valid metadata (in which case we can't compare mtime, so we fetch to be safe).
          const shouldUpdate =
            !cachedEntry ||
            (fileMetadata && cachedEntry.mtime < fileMetadata.mtime) ||
            !fileMetadata;

          if (shouldUpdate) {
            if (!fileMetadata) {
              logger.warning(
                `File has missing or invalid metadata, attempting to fetch content directly to recover: ${filePath}`,
                { ...context, filePath },
              );
            }

            const noteJson = (await this.obsidianService.getFileContent(
              filePath,
              "json",
              context,
            )) as NoteJson;

            // After fetching, we must validate the response before caching.
            if (
              noteJson &&
              typeof noteJson.content === "string" &&
              noteJson.stat?.mtime
            ) {
              this.vaultContentCache.set(filePath, {
                content: noteJson.content,
                mtime: noteJson.stat.mtime,
              });

              if (!cachedEntry) {
                filesAdded++;
                logger.debug(`Added new file to cache: ${filePath}`, {
                  ...context,
                  filePath,
                });
              } else {
                filesUpdated++;
                logger.debug(`Updated modified file in cache: ${filePath}`, {
                  ...context,
                  filePath,
                });
              }
            } else {
              logger.warning(
                `Skipping file during cache refresh because fetched content was invalid: ${filePath}`,
                { ...context, filePath },
              );
            }
          }
        } catch (error) {
          logger.error(
            `Failed to process file during cache refresh: ${filePath}. Skipping. Error: ${
              error instanceof Error ? error.message : String(error)
            }`,
            { ...context, filePath },
          );
        }
      }

      const duration = (Date.now() - startTime) / 1000;
      if (isInitialBuild) {
        this.isCacheReady = true;
        logger.info(
          `Initial vault cache build completed in ${duration.toFixed(2)}s. Cached ${this.vaultContentCache.size} files.`,
          context,
        );
      } else {
        logger.info(
          `Vault cache refresh completed in ${duration.toFixed(2)}s. Added: ${filesAdded}, Updated: ${filesUpdated}, Removed: ${filesRemoved}. Total cached: ${this.vaultContentCache.size}.`,
          context,
        );
      }
    } catch (error) {
      logger.error(
        `Critical error during vault cache refresh. Cache may be incomplete. Error: ${error instanceof Error ? error.message : String(error)}`,
        context,
      );
      if (isInitialBuild) {
        this.isCacheReady = false;
      }
    } finally {
      this.isBuilding = false;
    }
  }

  /**
   * Helper to recursively list all markdown files. Similar to the one in search logic.
   * @param dirPath - Starting directory path.
   * @param context - Request context.
   * @param visitedDirs - Set to track visited directories.
   * @returns Array of file paths.
   */
  private async listAllMarkdownFiles(
    dirPath: string,
    context: RequestContext,
    visitedDirs: Set<string> = new Set(),
  ): Promise<string[]> {
    const operation = "listAllMarkdownFiles";
    const opContext = { ...context, operation, dirPath };
    const normalizedPath = path.posix.normalize(dirPath === "" ? "/" : dirPath);

    if (visitedDirs.has(normalizedPath)) {
      logger.warning(
        `Cycle detected or directory already visited during cache build: ${normalizedPath}. Skipping.`,
        opContext,
      );
      return [];
    }
    visitedDirs.add(normalizedPath);

    let markdownFiles: string[] = [];
    try {
      const entries = await this.obsidianService.listFiles(
        normalizedPath,
        opContext,
      );
      for (const entry of entries) {
        const fullPath = path.posix.join(normalizedPath, entry);
        if (entry.endsWith("/")) {
          const subDirFiles = await this.listAllMarkdownFiles(
            fullPath,
            opContext,
            visitedDirs,
          );
          markdownFiles = markdownFiles.concat(subDirFiles);
        } else if (entry.toLowerCase().endsWith(".md")) {
          markdownFiles.push(fullPath);
        }
      }
      return markdownFiles;
    } catch (error) {
      const errMsg = `Failed to list directory during cache build scan: ${normalizedPath}`;
      const err = error as McpError | Error; // Type assertion

      // For any listing error (not found, permissions, etc.), just log it and skip the directory.
      // This makes the cache build resilient to vault inconsistencies.
      if (err instanceof McpError && err.code === BaseErrorCode.NOT_FOUND) {
        logger.debug(`${errMsg} - Directory not found, skipping.`, opContext);
      } else if (err instanceof Error) {
        logger.error(
          `${errMsg}. Skipping. Error: ${err.message}`,
          err,
          opContext,
        );
      } else {
        logger.error(`${errMsg}. Skipping.`, opContext);
      }

      // Return an empty array to allow the cache build to continue with other directories.
      return [];
    }
  }
}
</file>

<file path="generated-types.ts">
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Returns basic details about the server.
     *
     * @description Returns basic details about the server as well as your authentication status.
     *
     *     This is the only API request that does *not* require authentication.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              /** @description Is your current request authenticated? */
              authenticated?: boolean;
              /** @description 'OK' */
              ok?: string;
              /** @description 'Obsidian Local REST API' */
              service?: string;
              versions?: {
                /** @description Obsidian plugin API version */
                obsidian?: string;
                /** @description Plugin version. */
                self?: string;
              };
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/active/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return the content of the active file open in Obsidian.
     *
     * @description Returns the content of the currently active file in Obsidian.
     *
     *     If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
            "text/markdown": string;
          };
        };
        /** @description File does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /** Update the content of the active file open in Obsidian.
     *      */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description Content of the file you would like to upload. */
      requestBody: {
        content: {
          "*/*": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Append content to the active file open in Obsidian.
     *
     * @description Appends content to the end of the currently-open note.
     *
     *     If you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      /** @description Content you would like to append. */
      requestBody: {
        content: {
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Deletes the currently-active file in Obsidian.
     *      */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description File does not exist. */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /**
     * Partially update content in the currently open note.
     *
     * @description Inserts content into the currently-open note relative to a heading, block refeerence, or frontmatter field within that document.
     *
     *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
     *
     *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
     *
     *     # Examples
     *
     *     All of the below examples assume you have a document that looks like
     *     this:
     *
     *     ```markdown
     *     ---
     *     alpha: 1
     *     beta: test
     *     delta:
     *     zeta: 1
     *     yotta: 1
     *     gamma:
     *     - one
     *     - two
     *     ---
     *
     *     # Heading 1
     *
     *     This is the content for heading one
     *
     *     Also references some [[#^484ef2]]
     *
     *     ## Subheading 1:1
     *     Content for Subheading 1:1
     *
     *     ### Subsubheading 1:1:1
     *
     *     ### Subsubheading 1:1:2
     *
     *     Testing how block references work for a table.[[#^2c7cfa]]
     *     Some content for Subsubheading 1:1:2
     *
     *     More random text.
     *
     *     ^2d9b4a
     *
     *     ## Subheading 1:2
     *
     *     Content for Subheading 1:2.
     *
     *     some content with a block reference ^484ef2
     *
     *     ## Subheading 1:3
     *     | City         | Population |
     *     | ------------ | ---------- |
     *     | Seattle, WA  | 8          |
     *     | Portland, OR | 4          |
     *
     *     ^2c7cfa
     *     ```
     *
     *     ## Append Content Below a Heading
     *
     *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
     *     you could send a request with the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `heading`
     *     - `Target`: `Heading 1::Subheading 1:1:1`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Append Content to a Block Reference
     *
     *     If you wanted to append the content "Hello" below the block referenced by
     *     "2d9b4a" above ("More random text."), you could send the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `block`
     *     - `Target`: `2d9b4a`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Add a Row to a Table Referenced by a Block Reference
     *
     *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
     *     referenced by the block reference `2c7cfa`, you could send the following
     *     headers:
     *
     *     - `Operation`: `append`
     *     - `TargetType`: `block`
     *     - `Target`: `2c7cfa`
     *     - `Content-Type`: `application/json`
     *     - with the request body: `[["Chicago, IL", "16"]]`
     *
     *     The use of a `Content-Type` of `application/json` allows the API
     *     to infer that member of your array represents rows and columns of your
     *     to append to the referenced table.  You can of course just use a
     *     `Content-Type` of `text/markdown`, but in such a case you'll have to
     *     format your table row manually instead of letting the library figure
     *     it out for you.
     *
     *     You also have the option of using `prepend` (in which case, your new
     *     row would be the first -- right below the table heading) or `replace` (in which
     *     case all rows except the table heading would be replaced by the new row(s)
     *     you supplied).
     *
     *     ## Setting a Frontmatter Field
     *
     *     If you wanted to set the frontmatter field `alpha` to `2`, you could
     *     send the following headers:
     *
     *     - `Operation`: `replace`
     *     - `TargetType`: `frontmatter`
     *     - `Target`: `beep`
     *     - with the request body `2`
     *
     *     If you're setting a frontmatter field that might not already exist
     *     you may want to use the `Create-Target-If-Missing` header so the
     *     new frontmatter field is created and set to your specified value
     *     if it doesn't already exist.
     *
     *     You may find using a `Content-Type` of `application/json` to be
     *     particularly useful in the case of frontmatter since frontmatter
     *     fields' values are JSON data, and the API can be smarter about
     *     interpreting yoru `prepend` or `append` requests if you specify
     *     your data as JSON (particularly when appending, for example,
     *     list items).
     *
     */
    patch: {
      parameters: {
        query?: never;
        header: {
          /** @description Patch operation to perform */
          Operation: "append" | "prepend" | "replace";
          /** @description Type of target to patch */
          "Target-Type": "heading" | "block" | "frontmatter";
          /** @description Delimiter to use for nested targets (i.e. Headings) */
          "Target-Delimiter"?: string;
          /** @description Target to patch; this value can be URL-Encoded and *must*
           *     be URL-Encoded if it includes non-ASCII characters.
           *      */
          Target: string;
          /** @description Trim whitespace from Target before applying patch? */
          "Trim-Target-Whitespace"?: "true" | "false";
        };
        path?: never;
        cookie?: never;
      };
      /** @description Content you would like to insert. */
      requestBody: {
        content: {
          "application/json": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request; see response message for details. */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    trace?: never;
  };
  "/commands/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a list of available commands.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description A list of available commands. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            /** @example {
             *       "commands": [
             *         {
             *           "id": "global-search:open",
             *           "name": "Search: Search in all files"
             *         },
             *         {
             *           "id": "graph:open",
             *           "name": "Graph view: Open graph view"
             *         }
             *       ]
             *     } */
            "application/json": {
              commands?: {
                id?: string;
                name?: string;
              }[];
            };
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/commands/{commandId}/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Execute a command.
     *      */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The id of the command to execute */
          commandId: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description The command you specified does not exist. */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/obsidian-local-rest-api.crt": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns the certificate in use by this API.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/open/{filename}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Open the specified document in the Obsidian user interface.
     *
     * @description Note: Obsidian will create a new document at the path you have
     *     specified if such a document did not already exist.
     *
     */
    post: {
      parameters: {
        query?: {
          /** @description Open this as a new leaf? */
          newLeaf?: boolean;
        };
        header?: never;
        path: {
          /** @description Path to the file to return (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/openapi.yaml": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Returns OpenAPI YAML document describing the capabilities of this API.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/periodic/{period}/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get current periodic note for the specified period.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
            "text/markdown": string;
          };
        };
        /** @description File does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /** Update the content of the current periodic note for the specified period.
     *      */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content of the file you would like to upload. */
      requestBody: {
        content: {
          "*/*": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Append content to the current periodic note for the specified period.
     *
     * @description Note that this will create the relevant periodic note if necessary.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content you would like to append. */
      requestBody: {
        content: {
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Delete the current periodic note for the specified period.
     *      */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description File does not exist. */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /**
     * Partially update content in the current periodic note for the specified period.
     *
     * @description Inserts content into the current periodic note for the specified period relative to a heading, block refeerence, or frontmatter field within that document.
     *
     *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
     *
     *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
     *
     *     # Examples
     *
     *     All of the below examples assume you have a document that looks like
     *     this:
     *
     *     ```markdown
     *     ---
     *     alpha: 1
     *     beta: test
     *     delta:
     *     zeta: 1
     *     yotta: 1
     *     gamma:
     *     - one
     *     - two
     *     ---
     *
     *     # Heading 1
     *
     *     This is the content for heading one
     *
     *     Also references some [[#^484ef2]]
     *
     *     ## Subheading 1:1
     *     Content for Subheading 1:1
     *
     *     ### Subsubheading 1:1:1
     *
     *     ### Subsubheading 1:1:2
     *
     *     Testing how block references work for a table.[[#^2c7cfa]]
     *     Some content for Subsubheading 1:1:2
     *
     *     More random text.
     *
     *     ^2d9b4a
     *
     *     ## Subheading 1:2
     *
     *     Content for Subheading 1:2.
     *
     *     some content with a block reference ^484ef2
     *
     *     ## Subheading 1:3
     *     | City         | Population |
     *     | ------------ | ---------- |
     *     | Seattle, WA  | 8          |
     *     | Portland, OR | 4          |
     *
     *     ^2c7cfa
     *     ```
     *
     *     ## Append Content Below a Heading
     *
     *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
     *     you could send a request with the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `heading`
     *     - `Target`: `Heading 1::Subheading 1:1:1`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Append Content to a Block Reference
     *
     *     If you wanted to append the content "Hello" below the block referenced by
     *     "2d9b4a" above ("More random text."), you could send the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `block`
     *     - `Target`: `2d9b4a`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Add a Row to a Table Referenced by a Block Reference
     *
     *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
     *     referenced by the block reference `2c7cfa`, you could send the following
     *     headers:
     *
     *     - `Operation`: `append`
     *     - `TargetType`: `block`
     *     - `Target`: `2c7cfa`
     *     - `Content-Type`: `application/json`
     *     - with the request body: `[["Chicago, IL", "16"]]`
     *
     *     The use of a `Content-Type` of `application/json` allows the API
     *     to infer that member of your array represents rows and columns of your
     *     to append to the referenced table.  You can of course just use a
     *     `Content-Type` of `text/markdown`, but in such a case you'll have to
     *     format your table row manually instead of letting the library figure
     *     it out for you.
     *
     *     You also have the option of using `prepend` (in which case, your new
     *     row would be the first -- right below the table heading) or `replace` (in which
     *     case all rows except the table heading would be replaced by the new row(s)
     *     you supplied).
     *
     *     ## Setting a Frontmatter Field
     *
     *     If you wanted to set the frontmatter field `alpha` to `2`, you could
     *     send the following headers:
     *
     *     - `Operation`: `replace`
     *     - `TargetType`: `frontmatter`
     *     - `Target`: `beep`
     *     - with the request body `2`
     *
     *     If you're setting a frontmatter field that might not already exist
     *     you may want to use the `Create-Target-If-Missing` header so the
     *     new frontmatter field is created and set to your specified value
     *     if it doesn't already exist.
     *
     *     You may find using a `Content-Type` of `application/json` to be
     *     particularly useful in the case of frontmatter since frontmatter
     *     fields' values are JSON data, and the API can be smarter about
     *     interpreting yoru `prepend` or `append` requests if you specify
     *     your data as JSON (particularly when appending, for example,
     *     list items).
     *
     */
    patch: {
      parameters: {
        query?: never;
        header: {
          /** @description Patch operation to perform */
          Operation: "append" | "prepend" | "replace";
          /** @description Type of target to patch */
          "Target-Type": "heading" | "block" | "frontmatter";
          /** @description Delimiter to use for nested targets (i.e. Headings) */
          "Target-Delimiter"?: string;
          /** @description Target to patch; this value can be URL-Encoded and *must*
           *     be URL-Encoded if it includes non-ASCII characters.
           *      */
          Target: string;
          /** @description Trim whitespace from Target before applying patch? */
          "Trim-Target-Whitespace"?: "true" | "false";
        };
        path: {
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content you would like to insert. */
      requestBody: {
        content: {
          "application/json": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request; see response message for details. */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    trace?: never;
  };
  "/periodic/{period}/{year}/{month}/{day}/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get the periodic note for the specified period and date.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The year of the date for which you would like to grab a periodic note. */
          year: number;
          /** @description The month (1-12) of the date for which you would like to grab a periodic note. */
          month: number;
          /** @description The day (1-31) of the date for which you would like to grab a periodic note. */
          day: number;
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
            "text/markdown": string;
          };
        };
        /** @description File does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /** Update the content of the periodic note for the specified period and date.
     *      */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The year of the date for which you would like to grab a periodic note. */
          year: number;
          /** @description The month (1-12) of the date for which you would like to grab a periodic note. */
          month: number;
          /** @description The day (1-31) of the date for which you would like to grab a periodic note. */
          day: number;
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content of the file you would like to upload. */
      requestBody: {
        content: {
          "*/*": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Append content to the periodic note for the specified period and date.
     *
     * @description This will create the relevant periodic note if necessary.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The year of the date for which you would like to grab a periodic note. */
          year: number;
          /** @description The month (1-12) of the date for which you would like to grab a periodic note. */
          month: number;
          /** @description The day (1-31) of the date for which you would like to grab a periodic note. */
          day: number;
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content you would like to append. */
      requestBody: {
        content: {
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Delete the periodic note for the specified period and date.
     *
     * @description Deletes the periodic note for the specified period.
     *
     */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description The year of the date for which you would like to grab a periodic note. */
          year: number;
          /** @description The month (1-12) of the date for which you would like to grab a periodic note. */
          month: number;
          /** @description The day (1-31) of the date for which you would like to grab a periodic note. */
          day: number;
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description File does not exist. */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /**
     * Partially update content in the periodic note for the specified period and date.
     *
     * @description Inserts content into a periodic note relative to a heading, block refeerence, or frontmatter field within that document.
     *
     *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
     *
     *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
     *
     *     # Examples
     *
     *     All of the below examples assume you have a document that looks like
     *     this:
     *
     *     ```markdown
     *     ---
     *     alpha: 1
     *     beta: test
     *     delta:
     *     zeta: 1
     *     yotta: 1
     *     gamma:
     *     - one
     *     - two
     *     ---
     *
     *     # Heading 1
     *
     *     This is the content for heading one
     *
     *     Also references some [[#^484ef2]]
     *
     *     ## Subheading 1:1
     *     Content for Subheading 1:1
     *
     *     ### Subsubheading 1:1:1
     *
     *     ### Subsubheading 1:1:2
     *
     *     Testing how block references work for a table.[[#^2c7cfa]]
     *     Some content for Subsubheading 1:1:2
     *
     *     More random text.
     *
     *     ^2d9b4a
     *
     *     ## Subheading 1:2
     *
     *     Content for Subheading 1:2.
     *
     *     some content with a block reference ^484ef2
     *
     *     ## Subheading 1:3
     *     | City         | Population |
     *     | ------------ | ---------- |
     *     | Seattle, WA  | 8          |
     *     | Portland, OR | 4          |
     *
     *     ^2c7cfa
     *     ```
     *
     *     ## Append Content Below a Heading
     *
     *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
     *     you could send a request with the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `heading`
     *     - `Target`: `Heading 1::Subheading 1:1:1`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Append Content to a Block Reference
     *
     *     If you wanted to append the content "Hello" below the block referenced by
     *     "2d9b4a" above ("More random text."), you could send the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `block`
     *     - `Target`: `2d9b4a`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Add a Row to a Table Referenced by a Block Reference
     *
     *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
     *     referenced by the block reference `2c7cfa`, you could send the following
     *     headers:
     *
     *     - `Operation`: `append`
     *     - `TargetType`: `block`
     *     - `Target`: `2c7cfa`
     *     - `Content-Type`: `application/json`
     *     - with the request body: `[["Chicago, IL", "16"]]`
     *
     *     The use of a `Content-Type` of `application/json` allows the API
     *     to infer that member of your array represents rows and columns of your
     *     to append to the referenced table.  You can of course just use a
     *     `Content-Type` of `text/markdown`, but in such a case you'll have to
     *     format your table row manually instead of letting the library figure
     *     it out for you.
     *
     *     You also have the option of using `prepend` (in which case, your new
     *     row would be the first -- right below the table heading) or `replace` (in which
     *     case all rows except the table heading would be replaced by the new row(s)
     *     you supplied).
     *
     *     ## Setting a Frontmatter Field
     *
     *     If you wanted to set the frontmatter field `alpha` to `2`, you could
     *     send the following headers:
     *
     *     - `Operation`: `replace`
     *     - `TargetType`: `frontmatter`
     *     - `Target`: `beep`
     *     - with the request body `2`
     *
     *     If you're setting a frontmatter field that might not already exist
     *     you may want to use the `Create-Target-If-Missing` header so the
     *     new frontmatter field is created and set to your specified value
     *     if it doesn't already exist.
     *
     *     You may find using a `Content-Type` of `application/json` to be
     *     particularly useful in the case of frontmatter since frontmatter
     *     fields' values are JSON data, and the API can be smarter about
     *     interpreting yoru `prepend` or `append` requests if you specify
     *     your data as JSON (particularly when appending, for example,
     *     list items).
     *
     */
    patch: {
      parameters: {
        query?: never;
        header: {
          /** @description Patch operation to perform */
          Operation: "append" | "prepend" | "replace";
          /** @description Type of target to patch */
          "Target-Type": "heading" | "block" | "frontmatter";
          /** @description Delimiter to use for nested targets (i.e. Headings) */
          "Target-Delimiter"?: string;
          /** @description Target to patch; this value can be URL-Encoded and *must*
           *     be URL-Encoded if it includes non-ASCII characters.
           *      */
          Target: string;
          /** @description Trim whitespace from Target before applying patch? */
          "Trim-Target-Whitespace"?: "true" | "false";
        };
        path: {
          /** @description The year of the date for which you would like to grab a periodic note. */
          year: number;
          /** @description The month (1-12) of the date for which you would like to grab a periodic note. */
          month: number;
          /** @description The day (1-31) of the date for which you would like to grab a periodic note. */
          day: number;
          /** @description The name of the period for which you would like to grab a periodic note. */
          period: "daily" | "weekly" | "monthly" | "quarterly" | "yearly";
        };
        cookie?: never;
      };
      /** @description Content you would like to insert. */
      requestBody: {
        content: {
          "application/json": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request; see response message for details. */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    trace?: never;
  };
  "/search/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search for documents matching a specified search query
     *
     * @description Evaluates a provided query against each file in your vault.
     *
     *     This endpoint supports multiple query formats.  Your query should be specified in your request's body, and will be interpreted according to the `Content-type` header you specify from the below options.Additional query formats may be added in the future.
     *
     *     # Dataview DQL (`application/vnd.olrapi.dataview.dql+txt`)
     *
     *     Accepts a `TABLE`-type Dataview query as a text string.  See [Dataview](https://blacksmithgu.github.io/obsidian-dataview/query/queries/)'s query documentation for information on how to construct a query.
     *
     *     # JsonLogic (`application/vnd.olrapi.jsonlogic+json`)
     *
     *     Accepts a JsonLogic query specified as JSON.  See [JsonLogic](https://jsonlogic.com/operations.html)'s documentation for information about the base set of operators available, but in addition to those operators the following operators are available:
     *
     *     - `glob: [PATTERN, VALUE]`: Returns `true` if a string matches a glob pattern.  E.g.: `{"glob": ["*.foo", "bar.foo"]}` is `true` and `{"glob": ["*.bar", "bar.foo"]}` is `false`.
     *     - `regexp: [PATTERN, VALUE]`: Returns `true` if a string matches a regular expression.  E.g.: `{"regexp": [".*\.foo", "bar.foo"]` is `true` and `{"regexp": [".*\.bar", "bar.foo"]}` is `false`.
     *
     *     Returns only non-falsy results.  "Non-falsy" here treats the following values as "falsy":
     *
     *     - `false`
     *     - `null` or `undefined`
     *     - `0`
     *     - `[]`
     *     - `{}`
     *
     *     Files are represented as an object having the schema described
     *     in the Schema named 'NoteJson' at the bottom of this page.
     *     Understanding the shape of a JSON object from a schema can be
     *     tricky; so you may find it helpful to examine the generated metadata
     *     for individual files in your vault to understand exactly what values
     *     are returned.  To see that, access the `GET` `/vault/{filePath}`
     *     route setting the header:
     *     `Accept: application/vnd.olrapi.note+json`.  See examples below
     *     for working examples of queries performing common search operations.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody: {
        content: {
          "application/vnd.olrapi.dataview.dql+txt": string;
          "application/vnd.olrapi.jsonlogic+json": {
            [key: string]: unknown;
          };
        };
      };
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              /** @description Path to the matching file */
              filename: string;
              result:
                | string
                | number
                | unknown[]
                | Record<string, never>
                | boolean;
            }[];
          };
        };
        /** @description Bad request.  Make sure you have specified an acceptable
         *     Content-Type for your search query.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/search/simple/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Search for documents matching a specified text query
     *      */
    post: {
      parameters: {
        query: {
          /** @description Your search query */
          query: string;
          /** @description How much context to return around the matching string */
          contextLength?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": {
              /** @description Path to the matching file */
              filename?: string;
              matches?: {
                context: string;
                match: {
                  end: number;
                  start: number;
                };
              }[];
              score?: number;
            }[];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/vault/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List files that exist in the root of your vault.
     *
     * @description Lists files in the root directory of your vault.
     *
     *     Note: that this is exactly the same API endpoint as the below "List files that exist in the specified directory." and exists here only due to a quirk of this particular interactive tool.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            /** @example {
             *       "files": [
             *         "mydocument.md",
             *         "somedirectory/"
             *       ]
             *     } */
            "application/json": {
              files?: string[];
            };
          };
        };
        /** @description Directory does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  "/vault/{filename}": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Return the content of a single file in your vault.
     *
     * @description Returns the content of the file at the specified path in your vault should the file exist.
     *
     *     If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
     *
     */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/vnd.olrapi.note+json": components["schemas"]["NoteJson"];
            "text/markdown": string;
          };
        };
        /** @description File does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /**
     * Create a new file in your vault or update the content of an existing one.
     *
     * @description Creates a new file in your vault or updates the content of an existing one if the specified file already exists.
     *
     */
    put: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      /** @description Content of the file you would like to upload. */
      requestBody: {
        content: {
          "*/*": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
         *      */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /**
     * Append content to a new or existing file.
     *
     * @description Appends content to the end of an existing note. If the specified file does not yet exist, it will be created as an empty file.
     *
     *     If you would like to insert text relative to a particular heading, block reference, or frontmatter field instead of appending to the end of the file, see 'patch'.
     *
     */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      /** @description Content you would like to append. */
      requestBody: {
        content: {
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    /** Delete a particular file in your vault.
     *      */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description File does not exist. */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    options?: never;
    /**
     * Return metadata for a single file in your vault.
     *
     * @description Returns metadata about a file in your vault via headers.
     *
     */
    head: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. See headers for metadata. */
        200: {
          headers: {
            "x-obsidian-mtime"?: number;
            "x-obsidian-ctime"?: number;
            "content-length"?: number;
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description File does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
      };
    };
    /**
     * Partially update content in an existing note.
     *
     * @description Inserts content into an existing note relative to a heading, block refeerence, or frontmatter field within that document.
     *
     *     Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
     *
     *     Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
     *
     *     # Examples
     *
     *     All of the below examples assume you have a document that looks like
     *     this:
     *
     *     ```markdown
     *     ---
     *     alpha: 1
     *     beta: test
     *     delta:
     *     zeta: 1
     *     yotta: 1
     *     gamma:
     *     - one
     *     - two
     *     ---
     *
     *     # Heading 1
     *
     *     This is the content for heading one
     *
     *     Also references some [[#^484ef2]]
     *
     *     ## Subheading 1:1
     *     Content for Subheading 1:1
     *
     *     ### Subsubheading 1:1:1
     *
     *     ### Subsubheading 1:1:2
     *
     *     Testing how block references work for a table.[[#^2c7cfa]]
     *     Some content for Subsubheading 1:1:2
     *
     *     More random text.
     *
     *     ^2d9b4a
     *
     *     ## Subheading 1:2
     *
     *     Content for Subheading 1:2.
     *
     *     some content with a block reference ^484ef2
     *
     *     ## Subheading 1:3
     *     | City         | Population |
     *     | ------------ | ---------- |
     *     | Seattle, WA  | 8          |
     *     | Portland, OR | 4          |
     *
     *     ^2c7cfa
     *     ```
     *
     *     ## Append Content Below a Heading
     *
     *     If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
     *     you could send a request with the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `heading`
     *     - `Target`: `Heading 1::Subheading 1:1:1`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Append Content to a Block Reference
     *
     *     If you wanted to append the content "Hello" below the block referenced by
     *     "2d9b4a" above ("More random text."), you could send the following headers:
     *
     *     - `Operation`: `append`
     *     - `Target-Type`: `block`
     *     - `Target`: `2d9b4a`
     *     - with the request body: `Hello`
     *
     *     The above would work just fine for `prepend` or `replace`, too, of course,
     *     but with different results.
     *
     *     ## Add a Row to a Table Referenced by a Block Reference
     *
     *     If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
     *     referenced by the block reference `2c7cfa`, you could send the following
     *     headers:
     *
     *     - `Operation`: `append`
     *     - `TargetType`: `block`
     *     - `Target`: `2c7cfa`
     *     - `Content-Type`: `application/json`
     *     - with the request body: `[["Chicago, IL", "16"]]`
     *
     *     The use of a `Content-Type` of `application/json` allows the API
     *     to infer that member of your array represents rows and columns of your
     *     to append to the referenced table.  You can of course just use a
     *     `Content-Type` of `text/markdown`, but in such a case you'll have to
     *     format your table row manually instead of letting the library figure
     *     it out for you.
     *
     *     You also have the option of using `prepend` (in which case, your new
     *     row would be the first -- right below the table heading) or `replace` (in which
     *     case all rows except the table heading would be replaced by the new row(s)
     *     you supplied).
     *
     *     ## Setting a Frontmatter Field
     *
     *     If you wanted to set the frontmatter field `alpha` to `2`, you could
     *     send the following headers:
     *
     *     - `Operation`: `replace`
     *     - `TargetType`: `frontmatter`
     *     - `Target`: `beep`
     *     - with the request body `2`
     *
     *     If you're setting a frontmatter field that might not already exist
     *     you may want to use the `Create-Target-If-Missing` header so the
     *     new frontmatter field is created and set to your specified value
     *     if it doesn't already exist.
     *
     *     You may find using a `Content-Type` of `application/json` to be
     *     particularly useful in the case of frontmatter since frontmatter
     *     fields' values are JSON data, and the API can be smarter about
     *     interpreting yoru `prepend` or `append` requests if you specify
     *     your data as JSON (particularly when appending, for example,
     *     list items).
     *
     */
    patch: {
      parameters: {
        query?: never;
        header: {
          /** @description Patch operation to perform */
          Operation: "append" | "prepend" | "replace";
          /** @description Type of target to patch */
          "Target-Type": "heading" | "block" | "frontmatter";
          /** @description Delimiter to use for nested targets (i.e. Headings) */
          "Target-Delimiter"?: string;
          /** @description Target to patch; this value can be URL-Encoded and *must*
           *     be URL-Encoded if it includes non-ASCII characters.
           *      */
          Target: string;
          /** @description Trim whitespace from Target before applying patch? */
          "Trim-Target-Whitespace"?: "true" | "false";
          /** @description If the target (e.g., a frontmatter key) does not exist, create it. */
          "Create-Target-If-Missing"?: "true" | "false";
          /** @description The content type of the request body. */
          "Content-Type"?: "text/markdown" | "application/json";
        };
        path: {
          /** @description Path to the relevant file (relative to your vault root).
           *      */
          filename: string;
        };
        cookie?: never;
      };
      /** @description Content you would like to insert. */
      requestBody: {
        content: {
          "application/json": string;
          "text/markdown": string;
        };
      };
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Bad Request; see response message for details. */
        400: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Your path references a directory instead of a file; this request method is valid only for updating files.
         *      */
        405: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    trace?: never;
  };
  "/vault/{pathToDirectory}/": {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List files that exist in the specified directory.
     *      */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          /** @description Path to list files from (relative to your vault root).  Note that empty directories will not be returned.
           *
           *     Note: this particular interactive tool requires that you provide an argument for this field, but the API itself will allow you to list the root folder of your vault. If you would like to try listing content in the root of your vault using this interactive tool, use the above "List files that exist in the root of your vault" form above.
           *      */
          pathToDirectory: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            /** @example {
             *       "files": [
             *         "mydocument.md",
             *         "somedirectory/"
             *       ]
             *     } */
            "application/json": {
              files?: string[];
            };
          };
        };
        /** @description Directory does not exist */
        404: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    Error: {
      /**
       * @description A 5-digit error code uniquely identifying this particular type of error.
       *
       * @example 40149
       */
      errorCode?: number;
      /**
       * @description Message describing the error.
       * @example A brief description of the error.
       */
      message?: string;
    };
    NoteJson: {
      content: string;
      frontmatter: {
        [key: string]: unknown;
      };
      path: string;
      stat: {
        ctime: number;
        mtime: number;
        size: number;
      };
      tags: string[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
</file>

<file path="index.ts">
/**
 * @module ObsidianRestApiService Barrel File
 * @description
 * Exports the singleton instance of the Obsidian REST API service and related types.
 */

// Removed singleton export
export { ObsidianRestApiService, PatchOptions } from "./service.js"; // Export the class itself
export { VaultCacheService } from "./vaultCache/index.js";
export type { components as ObsidianApi } from "./generated-types.js";
</file>

<file path="service.ts">
/**
 * @module ObsidianRestApiService
 * @description
 * This module provides the core implementation for the Obsidian REST API service.
 * It encapsulates the logic for making authenticated requests to the API endpoints.
 */

import createClient from "openapi-fetch";
import { config } from "../../config/index.js";
import { BaseErrorCode, McpError } from "../../types-global/errors.js";
import {
  logger,
  RequestContext,
  requestContextService,
} from "../../utils/index.js";
import { components, paths } from "./generated-types.js";
import { VaultCacheService } from "./vaultCache/index.js";
import {
  FetchError,
  handleApiError,
  encodeVaultPath,
  encodeDirectoryPath,
} from "./utils/index.js";

// Define a type for our client for easier use
export type ObsidianApiClient = ReturnType<typeof createClient<paths>>;
type NoteJson = components["schemas"]["NoteJson"];
type NoteStat = components["schemas"]["NoteJson"]["stat"];
type ObsidianCommand = NonNullable<
  paths["/commands/"]["get"]["responses"]["200"]["content"]["application/json"]["commands"]
>[number];
type Period =
  paths["/periodic/{period}/"]["get"]["parameters"]["path"]["period"];
type SimpleSearchResult =
  paths["/search/simple/"]["post"]["responses"]["200"]["content"]["application/json"];
type ComplexSearchResult =
  paths["/search/"]["post"]["responses"]["200"]["content"]["application/json"];

type PatchHeaders = paths["/vault/{filename}"]["patch"]["parameters"]["header"];

export interface PatchOptions {
  operation: "append" | "prepend" | "replace";
  targetType: "heading" | "block" | "frontmatter";
  target: string;
  targetDelimiter?: string;
  trimTargetWhitespace?: boolean;
  createTargetIfMissing?: boolean;
  contentType?: "text/markdown" | "application/json";
}

export class ObsidianRestApiService {
  private apiClient: ObsidianApiClient;
  private vaultCacheService: VaultCacheService | null = null;

  constructor() {
    if (!config.obsidianApiKey) {
      throw new McpError(
        BaseErrorCode.CONFIGURATION_ERROR,
        "Obsidian API Key is missing in configuration.",
        {},
      );
    }

    this.apiClient = createClient<paths>({
      baseUrl: config.obsidianBaseUrl.replace(/\/$/, ""),
      headers: {
        Authorization: `Bearer ${config.obsidianApiKey}`,
      },
    });

    logger.info(
      `ObsidianRestApiService initialized with base URL: ${config.obsidianBaseUrl}`,
      requestContextService.createRequestContext({
        operation: "ObsidianServiceInit",
        verifySsl: config.obsidianVerifySsl,
      }),
    );
  }

  public setVaultCacheService(service: VaultCacheService) {
    this.vaultCacheService = service;
  }

  private async _performWriteOperation(
    filePath: string | null | undefined,
    context: RequestContext,
    operation: () => Promise<void>,
  ): Promise<void> {
    await operation();
    if (this.vaultCacheService && filePath) {
      this.vaultCacheService
        .updateCacheForFile(filePath, context)
        .catch((err) => {
          logger.error(`Background cache update failed for ${filePath}`, {
            ...context,
            error: err,
          });
        });
    }
  }

  private _buildPatchHeaders(options: PatchOptions): PatchHeaders {
    const headers: PatchHeaders = {
      Operation: options.operation,
      "Target-Type": options.targetType,
      Target: encodeURIComponent(options.target),
    };
    if (options.targetDelimiter) {
      headers["Target-Delimiter"] = options.targetDelimiter;
    }
    if (options.trimTargetWhitespace !== undefined) {
      headers["Trim-Target-Whitespace"] = String(
        options.trimTargetWhitespace,
      ) as "true" | "false";
    }
    if (options.createTargetIfMissing !== undefined) {
      headers["Create-Target-If-Missing"] = String(
        options.createTargetIfMissing,
      ) as "true" | "false";
    }
    if (options.contentType) {
      headers["Content-Type"] = options.contentType;
    } else {
      headers["Content-Type"] = "text/markdown";
    }

    return headers;
  }

  // --- Status Method ---
  async checkStatus(context: RequestContext) {
    const { data, error } = await this.apiClient.GET(`/`, {});
    if (error) {
      logger.error(`Failed to check Obsidian API status`, {
        ...context,
        error,
      });
      throw handleApiError(error as FetchError, context, "checkStatus");
    }
    return data;
  }

  // --- Vault Methods ---

  async getFileContent(
    filePath: string,
    format: "markdown" | "json" = "markdown",
    context: RequestContext,
  ): Promise<string | NoteJson> {
    const acceptHeader =
      format === "json" ? "application/vnd.olrapi.note+json" : "text/markdown";
    const encodedFilename = encodeVaultPath(filePath);

    const { data, error } = await this.apiClient.GET(`/vault/{filename}`, {
      params: {
        path: { filename: encodedFilename },
      },
      headers: {
        Accept: acceptHeader,
      },
    });

    if (error) {
      logger.error(`Failed to get file content for ${filePath}`, {
        ...context,
        error,
      });
      throw handleApiError(error as FetchError, context, "getFileContent");
    }
    return data as string | NoteJson;
  }

  async updateFileContent(
    filePath: string,
    content: string,
    context: RequestContext,
  ): Promise<void> {
    await this._performWriteOperation(filePath, context, async () => {
      const encodedFilename = encodeVaultPath(filePath);
      const { error } = await this.apiClient.PUT(`/vault/{filename}`, {
        params: {
          path: { filename: encodedFilename },
        },
        headers: {
          "Content-Type": "text/markdown",
        },
        body: content,
      });

      if (error) {
        logger.error(`Failed to update file content for ${filePath}`, {
          ...context,
          error,
        });
        throw handleApiError(error as FetchError, context, "updateFileContent");
      }
    });
  }

  async appendFileContent(
    filePath: string,
    content: string,
    context: RequestContext,
  ): Promise<void> {
    await this._performWriteOperation(filePath, context, async () => {
      const encodedFilename = encodeVaultPath(filePath);
      const { error } = await this.apiClient.POST(`/vault/{filename}`, {
        params: {
          path: { filename: encodedFilename },
        },
        headers: {
          "Content-Type": "text/markdown",
        },
        body: content,
      });

      if (error) {
        logger.error(`Failed to append file content for ${filePath}`, {
          ...context,
          error,
        });
        throw handleApiError(error as FetchError, context, "appendFileContent");
      }
    });
  }

  async deleteFile(filePath: string, context: RequestContext): Promise<void> {
    await this._performWriteOperation(filePath, context, async () => {
      const encodedFilename = encodeVaultPath(filePath);
      const { error } = await this.apiClient.DELETE(`/vault/{filename}`, {
        params: {
          path: { filename: encodedFilename },
        },
      });

      if (error) {
        logger.error(`Failed to delete file ${filePath}`, {
          ...context,
          error,
        });
        throw handleApiError(error as FetchError, context, "deleteFile");
      }
    });
  }

  async listFiles(dirPath: string, context: RequestContext): Promise<string[]> {
    type FileListResponse =
      paths["/vault/"]["get"]["responses"]["200"]["content"]["application/json"];
    const encodedPath = encodeDirectoryPath(dirPath);

    const { data, error } = encodedPath
      ? await this.apiClient.GET(`/vault/{pathToDirectory}/`, {
          params: {
            path: { pathToDirectory: encodedPath },
          },
        })
      : await this.apiClient.GET(`/vault/`, {});

    if (error) {
      logger.error(`Failed to list files in ${dirPath}`, { ...context, error });
      throw handleApiError(error as FetchError, context, "listFiles");
    }
    return (data as FileListResponse).files ?? [];
  }

  async getFileMetadata(
    filePath: string,
    context: RequestContext,
  ): Promise<NoteStat | null> {
    const encodedFilename = encodeVaultPath(filePath);
    const { error, response } = await this.apiClient.HEAD(`/vault/{filename}`, {
      params: {
        path: { filename: encodedFilename },
      },
    });

    if (error) {
      if (response.status !== 404) {
        logger.error(`Failed to get file metadata for ${filePath}`, {
          ...context,
          error,
        });
      }
      return null;
    }

    if (response.ok && response.headers) {
      const headers = response.headers;
      return {
        mtime: headers.get("x-obsidian-mtime")
          ? parseFloat(headers.get("x-obsidian-mtime")!) * 1000
          : 0,
        ctime: headers.get("x-obsidian-ctime")
          ? parseFloat(headers.get("x-obsidian-ctime")!) * 1000
          : 0,
        size: headers.get("content-length")
          ? parseInt(headers.get("content-length")!, 10)
          : 0,
      };
    }
    return null;
  }

  // --- Search Methods ---

  async searchSimple(
    query: string,
    contextLength: number = 100,
    context: RequestContext,
  ): Promise<SimpleSearchResult> {
    const { data, error } = await this.apiClient.POST(`/search/simple/`, {
      params: {
        query: { query, contextLength },
      },
    });

    if (error) {
      logger.error(`Failed to perform simple search for "${query}"`, {
        ...context,
        error,
      });
      throw handleApiError(error as FetchError, context, "searchSimple");
    }
    return data;
  }

  async searchComplex(
    query: string | object,
    contentType:
      | "application/vnd.olrapi.dataview.dql+txt"
      | "application/vnd.olrapi.jsonlogic+json",
    context: RequestContext,
  ): Promise<ComplexSearchResult> {
    const { data, error } = await this.apiClient.POST(`/search/`, {
      headers: { "Content-Type": contentType },
      body: query as any,
    });

    if (error) {
      logger.error(`Failed to perform complex search`, { ...context, error });
      throw handleApiError(error as FetchError, context, "searchComplex");
    }
    return data;
  }

  // --- Command Methods ---

  async executeCommand(
    commandId: string,
    context: RequestContext,
  ): Promise<void> {
    const { error } = await this.apiClient.POST(`/commands/{commandId}/`, {
      params: {
        path: { commandId },
      },
    });

    if (error) {
      logger.error(`Failed to execute command ${commandId}`, {
        ...context,
        error,
      });
      throw handleApiError(error as FetchError, context, "executeCommand");
    }
  }

  async listCommands(context: RequestContext): Promise<ObsidianCommand[]> {
    const { data, error } = await this.apiClient.GET(`/commands/`, {});

    if (error) {
      logger.error(`Failed to list commands`, { ...context, error });
      throw handleApiError(error as FetchError, context, "listCommands");
    }
    return data.commands ?? [];
  }

  // --- Open Methods ---

  async openFile(
    filePath: string,
    newLeaf: boolean = false,
    context: RequestContext,
  ): Promise<void> {
    const { error } = await this.apiClient.POST(`/open/{filename}`, {
      params: {
        path: { filename: filePath },
        query: { newLeaf },
      },
    });

    if (error) {
      logger.error(`Failed to open file ${filePath}`, { ...context, error });
      throw handleApiError(error, context, "openFile");
    }
  }

  // --- Active File Methods ---

  async getActiveFile(
    format: "markdown" | "json" = "markdown",
    context: RequestContext,
  ): Promise<string | NoteJson> {
    const acceptHeader =
      format === "json" ? "application/vnd.olrapi.note+json" : "text/markdown";
    const { data, error } = await this.apiClient.GET(`/active/`, {
      headers: {
        Accept: acceptHeader,
      },
    });

    if (error) {
      logger.error(`Failed to get active file`, { ...context, error });
      throw handleApiError(error, context, "getActiveFile");
    }
    return data as string | NoteJson;
  }

  async getActiveFilePath(context: RequestContext): Promise<string | null> {
    const note = await this.getActiveFile("json", context);
    if (typeof note === "object" && note.path) {
      return note.path;
    }
    return null;
  }

  async updateActiveFile(
    content: string,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getActiveFilePath(context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.PUT(`/active/`, {
        headers: {
          "Content-Type": "text/markdown",
        },
        body: content,
      });

      if (error) {
        logger.error(`Failed to update active file`, { ...context, error });
        throw handleApiError(error as FetchError, context, "updateActiveFile");
      }
    });
  }

  async appendActiveFile(
    content: string,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getActiveFilePath(context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.POST(`/active/`, {
        headers: {
          "Content-Type": "text/markdown",
        },
        body: content,
      });

      if (error) {
        logger.error(`Failed to append to active file`, { ...context, error });
        throw handleApiError(error as FetchError, context, "appendActiveFile");
      }
    });
  }

  async deleteActiveFile(context: RequestContext): Promise<void> {
    const filePath = await this.getActiveFilePath(context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.DELETE(`/active/`, {});

      if (error) {
        logger.error(`Failed to delete active file`, { ...context, error });
        throw handleApiError(error as FetchError, context, "deleteActiveFile");
      }
    });
  }

  // --- Periodic Notes Methods ---

  async getPeriodicNote(
    period: Period,
    format: "markdown" | "json" = "markdown",
    context: RequestContext,
  ): Promise<string | NoteJson> {
    const acceptHeader =
      format === "json" ? "application/vnd.olrapi.note+json" : "text/markdown";
    const { data, error } = await this.apiClient.GET(`/periodic/{period}/`, {
      params: {
        path: { period },
      },
      headers: { Accept: acceptHeader },
    });

    if (error) {
      logger.error(`Failed to get periodic note for period ${period}`, {
        ...context,
        error,
      });
      throw handleApiError(error as FetchError, context, "getPeriodicNote");
    }
    return data as string | NoteJson;
  }

  async getPeriodicNotePath(
    period: Period,
    context: RequestContext,
  ): Promise<string | null> {
    const note = await this.getPeriodicNote(period, "json", context);
    if (typeof note === "object" && note.path) {
      return note.path;
    }
    return null;
  }

  async updatePeriodicNote(
    period: Period,
    content: string,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getPeriodicNotePath(period, context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.PUT(`/periodic/{period}/`, {
        params: {
          path: { period },
        },
        headers: { "Content-Type": "text/markdown" },
        body: content,
      });

      if (error) {
        logger.error(`Failed to update periodic note for period ${period}`, {
          ...context,
          error,
        });
        throw handleApiError(
          error as FetchError,
          context,
          "updatePeriodicNote",
        );
      }
    });
  }

  async appendPeriodicNote(
    period: Period,
    content: string,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getPeriodicNotePath(period, context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.POST(`/periodic/{period}/`, {
        params: {
          path: { period },
        },
        headers: { "Content-Type": "text/markdown" },
        body: content,
      });

      if (error) {
        logger.error(`Failed to append to periodic note for period ${period}`, {
          ...context,
          error,
        });
        throw handleApiError(
          error as FetchError,
          context,
          "appendPeriodicNote",
        );
      }
    });
  }

  async deletePeriodicNote(
    period: Period,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getPeriodicNotePath(period, context);
    await this._performWriteOperation(filePath, context, async () => {
      const { error } = await this.apiClient.DELETE(`/periodic/{period}/`, {
        params: {
          path: { period },
        },
      });

      if (error) {
        logger.error(`Failed to delete periodic note for period ${period}`, {
          ...context,
          error,
        });
        throw handleApiError(
          error as FetchError,
          context,
          "deletePeriodicNote",
        );
      }
    });
  }

  // --- Patch Methods ---

  async patchFile(
    filePath: string,
    content: string | object,
    options: PatchOptions,
    context: RequestContext,
  ): Promise<void> {
    await this._performWriteOperation(filePath, context, async () => {
      const headers = this._buildPatchHeaders(options);
      const requestData =
        typeof content === "object" ? JSON.stringify(content) : content;
      const encodedFilename = encodeVaultPath(filePath);

      const { error } = await this.apiClient.PATCH(`/vault/{filename}`, {
        params: {
          path: { filename: encodedFilename },
          header: headers,
        },
        body: requestData,
      });

      if (error) {
        logger.error(`Failed to patch file ${filePath}`, { ...context, error });
        throw handleApiError(error as FetchError, context, "patchFile");
      }
    });
  }

  async patchActiveFile(
    content: string | object,
    options: PatchOptions,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getActiveFilePath(context);
    await this._performWriteOperation(filePath, context, async () => {
      const headers = this._buildPatchHeaders(options);
      const requestData =
        typeof content === "object" ? JSON.stringify(content) : content;

      const { error } = await this.apiClient.PATCH(`/active/`, {
        params: {
          header: headers,
        },
        body: requestData,
      });

      if (error) {
        logger.error(`Failed to patch active file`, { ...context, error });
        throw handleApiError(error as FetchError, context, "patchActiveFile");
      }
    });
  }

  async patchPeriodicNote(
    period: Period,
    content: string | object,
    options: PatchOptions,
    context: RequestContext,
  ): Promise<void> {
    const filePath = await this.getPeriodicNotePath(period, context);
    await this._performWriteOperation(filePath, context, async () => {
      const headers = this._buildPatchHeaders(options);
      const requestData =
        typeof content === "object" ? JSON.stringify(content) : content;

      const { error } = await this.apiClient.PATCH(`/periodic/{period}/`, {
        params: {
          path: { period },
          header: headers,
        },
        body: requestData,
      });

      if (error) {
        logger.error(`Failed to patch periodic note for period ${period}`, {
          ...context,
          error,
        });
        throw handleApiError(error as FetchError, context, "patchPeriodicNote");
      }
    });
  }
}
</file>

</repository_files>


---

This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-08-22T09:27:38.686Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
obsidianDeleteNoteTool/
  index.ts
  logic.ts
  registration.ts
obsidianGlobalSearchTool/
  index.ts
  logic.ts
  registration.ts
obsidianListNotesTool/
  index.ts
  logic.ts
  registration.ts
obsidianManageFrontmatterTool/
  index.ts
  logic.ts
  registration.ts
obsidianManageTagsTool/
  index.ts
  logic.ts
  registration.ts
obsidianReadNoteTool/
  index.ts
  logic.ts
  registration.ts
obsidianSearchReplaceTool/
  index.ts
  logic.ts
  registration.ts
obsidianUpdateNoteTool/
  index.ts
  logic.ts
  registration.ts
schemas/
  jsonSchema.ts
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="obsidianDeleteNoteTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_delete_note' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_delete_note tool module.
 * It re-exports the primary registration function (`registerObsidianDeleteNoteTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */
export { registerObsidianDeleteNoteTool } from "./registration.js";
</file>

<file path="obsidianDeleteNoteTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_delete_note' tool.
 * @module src/mcp-server/tools/obsidianDeleteNoteTool/logic
 */

import { z } from "zod";
import { logger, type RequestContext } from "../../../utils/index.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/service.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";

export const ObsidianDeleteNoteInputSchema = z.object({
  filePath: z
    .string()
    .min(1)
    .describe(
      'The vault-relative path to the Obsidian note to be deleted (e.g., "archive/old-note.md"). Tries case-sensitive first, then case-insensitive fallback.',
    ),
});

export const ObsidianDeleteNoteOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
});

export type ObsidianDeleteNoteInput = z.infer<
  typeof ObsidianDeleteNoteInputSchema
>;
export type ObsidianDeleteNoteOutput = z.infer<
  typeof ObsidianDeleteNoteOutputSchema
>;

/**
 * Deletes a note in Obsidian, resolving the path case-insensitively if necessary.
 * @param params The validated input parameters.
 * @param context The request context for logging and tracing.
 * @param obsidianService An instance of the ObsidianRestApiService.
 * @returns A promise resolving with the structured response data.
 * @throws {McpError} If the file cannot be found or the delete operation fails.
 */
export async function obsidianDeleteNoteLogic(
  params: ObsidianDeleteNoteInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianDeleteNoteOutput> {
  const { filePath: originalFilePath } = params;
  logger.info(
    `Executing obsidianDeleteNoteLogic for path: '${originalFilePath}'`,
    {
      ...context,
      params,
    },
  );

  const effectiveFilePath = await resolveVaultPath(
    originalFilePath,
    context,
    (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
    (dp, ctx) => obsidianService.listFiles(dp, ctx),
  );

  await obsidianService.deleteFile(effectiveFilePath, context);

  const message =
    originalFilePath === effectiveFilePath
      ? `Obsidian note '${originalFilePath}' deleted successfully.`
      : `Obsidian note '${effectiveFilePath}' (found via case-insensitive match for '${originalFilePath}') deleted successfully.`;

  logger.info("obsidianDeleteNoteLogic completed successfully.", {
    ...context,
    result: message,
  });

  return {
    success: true,
    message,
  };
}
</file>

<file path="obsidianDeleteNoteTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_delete_note' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianDeleteNoteTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianDeleteNoteLogic,
  ObsidianDeleteNoteInput,
  ObsidianDeleteNoteInputSchema,
  ObsidianDeleteNoteOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_delete_note";
const TOOL_DESCRIPTION =
  "Permanently deletes a specified Obsidian note. Tries the exact path first, then attempts a case-insensitive fallback if the note is not found. Requires the vault-relative path including the file extension. Returns a success message.";

/**
 * Registers the 'obsidian_delete_note' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianDeleteNoteTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Delete Obsidian Note",
      description: TOOL_DESCRIPTION,
      inputSchema: ObsidianDeleteNoteInputSchema.shape,
      outputSchema: ObsidianDeleteNoteOutputSchema.shape,
      annotations: {
        readOnlyHint: false,
        destructiveHint: true,
      },
    },
    async (params: ObsidianDeleteNoteInput, callContext) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        // Explicitly validate the input using the Zod schema.
        const validatedParams = ObsidianDeleteNoteInputSchema.parse(params);

        const result = await obsidianDeleteNoteLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        logger.info("Tool execution successful", { ...handlerContext, result });

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: result.message,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianGlobalSearchTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_global_search' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_global_search tool module.
 * It re-exports the primary registration function (`registerObsidianGlobalSearchTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */

export { registerObsidianGlobalSearchTool } from "./registration.js"; // Ensure '.js' extension for ES module resolution
</file>

<file path="obsidianGlobalSearchTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_global_search' tool.
 * @module src/mcp-server/tools/obsidianGlobalSearchTool/logic
 */

import path from "node:path/posix";
import { z } from "zod";
import { config } from "../../../config/index.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import {
  components,
  paths,
} from "../../../services/obsidianRestAPI/generated-types.js";
import { VaultCacheService } from "../../../services/obsidianRestAPI/vaultCache/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import {
  dateParser,
  logger,
  type RequestContext,
} from "../../../utils/index.js";
import { formatTimestamp } from "../../../services/obsidianRestAPI/utils/index.js";

// 1. DEFINE the Zod input schema.
export const ObsidianGlobalSearchInputSchema = z.object({
  query: z
    .string()
    .min(1)
    .describe("The search query (text or regex pattern)."),
  searchInPath: z
    .string()
    .optional()
    .describe(
      "Optional vault-relative path to recursively search within (e.g., 'Notes/Projects'). If omitted, searches the entire vault.",
    ),
  contextLength: z
    .number()
    .int()
    .positive()
    .default(100)
    .describe("Characters of context around matches."),
  modified_since: z
    .string()
    .optional()
    .describe(
      "Filter files modified *since* this date/time (e.g., '2 weeks ago', '2024-01-15').",
    ),
  modified_until: z
    .string()
    .optional()
    .describe(
      "Filter files modified *until* this date/time (e.g., 'today', '2024-03-20 17:00').",
    ),
  useRegex: z
    .boolean()
    .default(false)
    .describe("Treat 'query' as regex. Defaults to false."),
  caseSensitive: z
    .boolean()
    .default(false)
    .describe("Perform case-sensitive search. Defaults to false."),
  pageSize: z
    .number()
    .int()
    .positive()
    .default(50)
    .describe("Maximum number of result files per page. Defaults to 50."),
  page: z
    .number()
    .int()
    .positive()
    .default(1)
    .describe("Page number of results to return. Defaults to 1."),
  maxMatchesPerFile: z
    .number()
    .int()
    .positive()
    .default(5)
    .describe("Maximum number of matches to show per file. Defaults to 5."),
});

// 2. DEFINE the Zod response schema.
const MatchContextSchema = z.object({
  context: z.string(),
  matchText: z.string().optional(),
  position: z.number().optional(),
});

const GlobalSearchResultSchema = z.object({
  path: z.string(),
  filename: z.string(),
  matches: z.array(MatchContextSchema),
  modifiedTime: z.string(),
  createdTime: z.string(),
  numericMtime: z.number(),
});

export const ObsidianGlobalSearchOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  results: z.array(GlobalSearchResultSchema),
  totalFilesFound: z.number(),
  totalMatchesFound: z.number(),
  currentPage: z.number(),
  pageSize: z.number(),
  totalPages: z.number(),
  alsoFoundInFiles: z.array(z.string()).optional(),
});

// 3. INFER and export TypeScript types.
export type ObsidianGlobalSearchInput = z.infer<
  typeof ObsidianGlobalSearchInputSchema
>;
export type ObsidianGlobalSearchOutput = z.infer<
  typeof ObsidianGlobalSearchOutputSchema
>;
type GlobalSearchResult = z.infer<typeof GlobalSearchResultSchema>;
type MatchContext = z.infer<typeof MatchContextSchema>;
type NoteJson = components["schemas"]["NoteJson"];
type SimpleSearchResult =
  paths["/search/simple/"]["post"]["responses"]["200"]["content"]["application/json"][number];

// Helper to find matches in a string, used by the cache fallback.
function findMatchesInContent(
  content: string,
  query: string,
  useRegex: boolean,
  caseSensitive: boolean,
  contextLength: number,
): MatchContext[] {
  const matches: MatchContext[] = [];
  let regex: RegExp;
  try {
    const flags = `g${caseSensitive ? "" : "i"}`;
    regex = useRegex
      ? new RegExp(query, flags)
      : new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), flags);
  } catch (e) {
    throw new McpError(
      BaseErrorCode.VALIDATION_ERROR,
      `Invalid regex pattern: ${query}`,
    );
  }
  let match;
  while ((match = regex.exec(content)) !== null) {
    const matchIndex = match.index;
    const matchText = match[0];
    const startIndex = Math.max(0, matchIndex - contextLength);
    const endIndex = Math.min(
      content.length,
      matchIndex + matchText.length + contextLength,
    );
    const contextSnippet = content.substring(startIndex, endIndex);
    matches.push({ context: contextSnippet });
    if (matchText.length === 0) regex.lastIndex++;
  }
  return matches;
}

// Helper to process and filter results from either API or cache.
async function processAndFilterResults(
  results: (SimpleSearchResult | GlobalSearchResult)[],
  params: ObsidianGlobalSearchInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<GlobalSearchResult[]> {
  const { searchInPath, modified_since, modified_until, maxMatchesPerFile } =
    params;
  const sinceDate = modified_since
    ? await dateParser.parseToDate(modified_since, context)
    : null;
  const untilDate = modified_until
    ? await dateParser.parseToDate(modified_until, context)
    : null;
  const searchPathPrefix = searchInPath
    ? path.normalize(searchInPath) + (searchInPath === "/" ? "" : "/")
    : "";

  const filteredResults: GlobalSearchResult[] = [];

  for (const result of results) {
    const filePath = "path" in result ? result.path : result.filename!;
    if (searchPathPrefix && !filePath.startsWith(searchPathPrefix)) {
      continue;
    }

    // For API results, we need to fetch metadata to filter by date.
    // For cache results, metadata is already present.
    let mtime: number, ctime: number;
    if ("numericMtime" in result) {
      mtime = result.numericMtime;
      ctime = (result as any).ctime ?? 0;
    } else {
      const noteJson = (await obsidianService.getFileContent(
        filePath,
        "json",
        context,
      )) as NoteJson;
      mtime = noteJson.stat.mtime;
      ctime = noteJson.stat.ctime;
    }

    if (
      (sinceDate && mtime < sinceDate.getTime()) ||
      (untilDate && mtime > untilDate.getTime())
    ) {
      continue;
    }

    filteredResults.push({
      path: filePath,
      filename: path.basename(filePath),
      matches: (result.matches ?? []).slice(0, maxMatchesPerFile),
      modifiedTime: formatTimestamp(mtime, context),
      createdTime: formatTimestamp(ctime, context),
      numericMtime: mtime,
    });
  }
  return filteredResults;
}

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianGlobalSearchLogic(
  params: ObsidianGlobalSearchInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
  vaultCacheService?: VaultCacheService,
): Promise<ObsidianGlobalSearchOutput> {
  const { query, contextLength, pageSize, page, useRegex, caseSensitive } =
    params;
  let allFilteredResults: GlobalSearchResult[] = [];
  let totalMatchesCount = 0;
  let strategyMessage = "";

  let apiFailedOrTimedOut = false;
  try {
    strategyMessage = "Attempting live API search... ";
    const apiResults: SimpleSearchResult[] = await Promise.race([
      obsidianService.searchSimple(query, contextLength, context),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error("API search timed out")),
          config.obsidianApiSearchTimeoutMs,
        ),
      ),
    ]);
    strategyMessage += `API search successful, returned ${apiResults.length} potential files. `;
    allFilteredResults = await processAndFilterResults(
      apiResults,
      params,
      context,
      obsidianService,
    );
    totalMatchesCount = allFilteredResults.reduce(
      (sum, r) => sum + r.matches.length,
      0,
    );
  } catch (apiError) {
    logger.warning("Live API search failed or timed out.", {
      ...context,
      apiError,
    });
    apiFailedOrTimedOut = true;
    strategyMessage += "API search failed or timed out. ";
  }

  if (apiFailedOrTimedOut) {
    if (vaultCacheService?.isReady()) {
      strategyMessage += "Falling back to in-memory cache. ";
      const cache = vaultCacheService.getCache();
      const cacheResults: GlobalSearchResult[] = [];

      for (const [filePath, cacheEntry] of cache.entries()) {
        const matches = findMatchesInContent(
          cacheEntry.content,
          query,
          useRegex,
          caseSensitive,
          contextLength,
        );
        if (matches.length > 0) {
          cacheResults.push({
            path: filePath,
            filename: path.basename(filePath),
            matches: matches,
            modifiedTime: "", // Will be populated in processAndFilterResults
            createdTime: "", // Will be populated in processAndFilterResults
            numericMtime: cacheEntry.mtime,
          });
        }
      }
      allFilteredResults = await processAndFilterResults(
        cacheResults,
        params,
        context,
        obsidianService,
      );
      totalMatchesCount = allFilteredResults.reduce(
        (sum, r) => sum + r.matches.length,
        0,
      );
    } else {
      throw new McpError(
        BaseErrorCode.SERVICE_UNAVAILABLE,
        "Live API search failed and the cache is not available or ready.",
      );
    }
  }

  allFilteredResults.sort((a, b) => b.numericMtime - a.numericMtime);

  const totalFilesFound = allFilteredResults.length;
  const totalPages = Math.ceil(totalFilesFound / pageSize);
  const startIndex = (page - 1) * pageSize;
  const paginatedResults = allFilteredResults.slice(
    startIndex,
    startIndex + pageSize,
  );

  const paginatedFilePaths = new Set(paginatedResults.map((r) => r.path));
  const alsoFoundInFiles =
    totalPages > 1
      ? [
          ...new Set(
            allFilteredResults
              .filter((r) => !paginatedFilePaths.has(r.path))
              .map((r) => r.filename),
          ),
        ]
      : undefined;

  const finalMessage = `${strategyMessage}Found ${totalMatchesCount} matches across ${totalFilesFound} files. Returning page ${page} of ${totalPages}.`;

  return {
    success: true,
    message: finalMessage,
    results: paginatedResults,
    totalFilesFound,
    totalMatchesFound: totalMatchesCount,
    currentPage: page,
    pageSize,
    totalPages,
    alsoFoundInFiles,
  };
}
</file>

<file path="obsidianGlobalSearchTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_global_search' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianGlobalSearchTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import {
  ObsidianRestApiService,
  VaultCacheService,
} from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianGlobalSearchLogic,
  ObsidianGlobalSearchInput,
  ObsidianGlobalSearchInputSchema,
  ObsidianGlobalSearchOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_global_search";
const TOOL_DESCRIPTION =
  "Performs a search across the Obsidian vault. Supports text or regex queries, filtering by modification date and path, and pagination. Returns a comprehensive JSON object with results and search metadata.";

/**
 * Registers the 'obsidian_global_search' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 * @param vaultCacheService An optional instance of the VaultCacheService for fallback searches.
 */
export const registerObsidianGlobalSearchTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
  vaultCacheService?: VaultCacheService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Search Obsidian Vault",
      description: TOOL_DESCRIPTION,
      inputSchema: ObsidianGlobalSearchInputSchema.shape,
      outputSchema: ObsidianGlobalSearchOutputSchema.shape,
      annotations: {
        readOnlyHint: true,
      },
    },
    async (params: ObsidianGlobalSearchInput, callContext) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianGlobalSearchInputSchema.parse(params);
        const result = await obsidianGlobalSearchLogic(
          validatedParams,
          handlerContext,
          obsidianService,
          vaultCacheService,
        );

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: `Search successful: ${result.message}`,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianListNotesTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_list_notes' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_list_notes tool module.
 * It re-exports the primary registration function (`registerObsidianListNotesTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */
export { registerObsidianListNotesTool } from "./registration.js";
</file>

<file path="obsidianListNotesTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_list_notes' tool.
 * @module src/mcp-server/tools/obsidianListNotesTool/logic
 */

import path from "node:path";
import { z } from "zod";
import { logger, type RequestContext } from "../../../utils/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { ObsidianRestApiService as ObsidianService } from "../../../services/obsidianRestAPI/service.js";

// 1. DEFINE the Zod input schema.
export const ObsidianListNotesInputSchema = z.object({
  dirPath: z
    .string()
    .describe(
      'The vault-relative path to the directory to list (e.g., "developer/atlas-mcp-server", "/" for root). Case-sensitive.',
    ),
  fileExtensionFilter: z
    .array(z.string().startsWith("."))
    .optional()
    .describe(
      'Optional array of file extensions (e.g., [".md"]) to filter files. Directories are always included.',
    ),
  nameRegexFilter: z
    .string()
    .nullable()
    .optional()
    .describe(
      "Optional regex pattern (JavaScript syntax) to filter results by name.",
    ),
  recursionDepth: z
    .number()
    .int()
    .default(-1)
    .describe(
      "Maximum recursion depth. 0 for no recursion, -1 for infinite (default).",
    ),
});

// 2. DEFINE the Zod response schema.
export const ObsidianListNotesOutputSchema = z.object({
  directoryPath: z.string(),
  tree: z.string(),
  totalEntries: z.number(),
});

// 3. INFER and export TypeScript types.
export type ObsidianListNotesInput = z.infer<
  typeof ObsidianListNotesInputSchema
>;
export type ObsidianListNotesOutput = z.infer<
  typeof ObsidianListNotesOutputSchema
>;

// Internal Type Definitions
interface FileTreeNode {
  name: string;
  type: "file" | "directory";
  children: FileTreeNode[];
}

// Helper Functions
function formatTree(
  nodes: FileTreeNode[],
  indent = "",
): { tree: string; count: number } {
  let treeString = "";
  let count = nodes.length;

  nodes.forEach((node, index) => {
    const isLast = index === nodes.length - 1;
    const prefix = isLast ? "└── " : "├── ";
    const childIndent = isLast ? "    " : "│   ";

    treeString += `${indent}${prefix}${node.name}\n`;

    if (node.children && node.children.length > 0) {
      const result = formatTree(node.children, indent + childIndent);
      treeString += result.tree;
      count += result.count;
    }
  });

  return { tree: treeString, count };
}

async function buildFileTree(
  dirPath: string,
  currentDepth: number,
  params: ObsidianListNotesInput,
  context: RequestContext,
  obsidianService: ObsidianService,
): Promise<FileTreeNode[]> {
  const { recursionDepth, fileExtensionFilter, nameRegexFilter } = params;

  if (recursionDepth !== -1 && currentDepth > recursionDepth) {
    return [];
  }

  let fileNames;
  try {
    fileNames = await obsidianService.listFiles(dirPath, context);
  } catch (error) {
    if (error instanceof McpError && error.code === BaseErrorCode.NOT_FOUND) {
      logger.warning(
        `Directory not found during recursive list: ${dirPath}. Skipping.`,
        context,
      );
      return [];
    }
    throw error;
  }

  const regex = nameRegexFilter ? new RegExp(nameRegexFilter) : null;
  const treeNodes: FileTreeNode[] = [];

  for (const name of fileNames) {
    const fullPath = path.posix.join(dirPath, name);
    const isDirectory = name.endsWith("/");
    const cleanName = isDirectory ? name.slice(0, -1) : name;

    if (regex && !regex.test(cleanName)) continue;
    if (
      !isDirectory &&
      fileExtensionFilter &&
      fileExtensionFilter.length > 0 &&
      !fileExtensionFilter.includes(path.posix.extname(name))
    ) {
      continue;
    }

    const node: FileTreeNode = {
      name: isDirectory ? `${cleanName}/` : cleanName,
      type: isDirectory ? "directory" : "file",
      children: isDirectory
        ? await buildFileTree(
            fullPath,
            currentDepth + 1,
            params,
            context,
            obsidianService,
          )
        : [],
    };
    treeNodes.push(node);
  }

  treeNodes.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type === "directory" ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });

  return treeNodes;
}

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianListNotesLogic(
  params: ObsidianListNotesInput,
  context: RequestContext,
  obsidianService: ObsidianService,
): Promise<ObsidianListNotesOutput> {
  const { dirPath } = params;
  const effectiveDirPath = dirPath === "" ? "/" : dirPath;
  logger.debug(
    `Executing obsidianListNotesLogic for path: ${effectiveDirPath}`,
    { ...context, params },
  );

  const fileTree = await buildFileTree(
    effectiveDirPath,
    0,
    params,
    context,
    obsidianService,
  );

  if (fileTree.length === 0) {
    return {
      directoryPath: effectiveDirPath,
      tree: "(empty or all items filtered)",
      totalEntries: 0,
    };
  }

  const { tree, count } = formatTree(fileTree);

  return {
    directoryPath: effectiveDirPath,
    tree: tree.trimEnd(),
    totalEntries: count,
  };
}
</file>

<file path="obsidianListNotesTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_list_notes' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianListNotesTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianListNotesLogic,
  ObsidianListNotesInput,
  ObsidianListNotesInputSchema,
  ObsidianListNotesOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_list_notes";
const TOOL_DESCRIPTION =
  "Lists Obsidian notes and subdirectories within a specified folder. Supports optional filtering by extension or name regex, and recursive listing to a specified depth (-1 for infinite). Returns a JSON object with the directory path, a formatted tree of its contents, and the total entry count. Use an empty string or '/' for dirPath to list the vault root.";

/**
 * Registers the 'obsidian_list_notes' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianListNotesTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "List Notes and Directories in Obsidian",
      description: TOOL_DESCRIPTION,
      inputSchema: ObsidianListNotesInputSchema.shape,
      outputSchema: ObsidianListNotesOutputSchema.shape,
      annotations: {
        readOnlyHint: true,
      },
    },
    async (params: ObsidianListNotesInput, callContext) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianListNotesInputSchema.parse(params);
        const result = await obsidianListNotesLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        const outputText = `Listed ${result.totalEntries} entries in '${result.directoryPath}':\n${result.tree}`;

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: outputText,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianManageFrontmatterTool/index.ts">
/**
 * @fileoverview Barrel file for the obsidian_manage_frontmatter tool.
 * @module src/mcp-server/tools/obsidianManageFrontmatterTool/index
 */

export * from "./logic.js";
export * from "./registration.js";
</file>

<file path="obsidianManageFrontmatterTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_manage_frontmatter' tool.
 * @module src/mcp-server/tools/obsidianManageFrontmatterTool/logic
 */

import { z } from "zod";
import { components } from "../../../services/obsidianRestAPI/generated-types.js";
import {
  ObsidianRestApiService,
  PatchOptions,
} from "../../../services/obsidianRestAPI/index.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";
import { type RequestContext } from "../../../utils/index.js";
import { JsonValueSchema } from "../schemas/jsonSchema.js";

type NoteJson = components["schemas"]["NoteJson"];

// 1. DEFINE the Zod input schema.
export const BaseObsidianManageFrontmatterInputSchema = z.object({
  filePath: z
    .string()
    .min(1)
    .describe(
      "The vault-relative path to the target note (e.g., 'projects/active/my-note.md').",
    ),
  operation: z
    .enum(["get", "set", "delete"])
    .describe(
      "The operation to perform on the frontmatter: 'get' to read a key, 'set' to create or update a key, or 'delete' to remove a key.",
    ),
  key: z
    .string()
    .min(1)
    .describe(
      "The name of the frontmatter key to target, such as 'status', 'tags', or 'aliases'.",
    ),
  value: JsonValueSchema.optional().describe(
    "The value to assign when using the 'set' operation. Can be a string, number, boolean, array, or a JSON object.",
  ),
});

export const ObsidianManageFrontmatterInputSchema =
  BaseObsidianManageFrontmatterInputSchema.refine(
    (data) => !(data.operation === "set" && data.value === undefined),
    {
      message: "A 'value' is required when the 'operation' is 'set'.",
      path: ["value"],
    },
  );

// 2. DEFINE the Zod response schema.
export const ObsidianManageFrontmatterOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  value: JsonValueSchema.optional(),
});

// 3. INFER and export TypeScript types.
export type ObsidianManageFrontmatterInput = z.infer<
  typeof ObsidianManageFrontmatterInputSchema
>;
export type ObsidianManageFrontmatterOutput = z.infer<
  typeof ObsidianManageFrontmatterOutputSchema
>;

/**
 * Manages frontmatter for a specific Obsidian note.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianManageFrontmatterLogic(
  params: ObsidianManageFrontmatterInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianManageFrontmatterOutput> {
  const { filePath, operation, key, value } = params;

  const effectiveFilePath = await resolveVaultPath(
    filePath,
    context,
    (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
    (dp, ctx) => obsidianService.listFiles(dp, ctx),
  );

  switch (operation) {
    case "get": {
      const note = (await obsidianService.getFileContent(
        effectiveFilePath,
        "json",
        context,
      )) as NoteJson;
      const retrievedValue = note.frontmatter?.[key];
      return {
        success: true,
        message: `Successfully retrieved key '${key}' from frontmatter.`,
        value: retrievedValue as z.infer<typeof JsonValueSchema>,
      };
    }

    case "set": {
      const patchOptions: PatchOptions = {
        operation: "replace",
        targetType: "frontmatter",
        target: key,
        createTargetIfMissing: true,
        contentType: "application/json",
      };
      await obsidianService.patchFile(
        effectiveFilePath,
        JSON.stringify(value),
        patchOptions,
        context,
      );
      return {
        success: true,
        message: `Successfully set key '${key}' in frontmatter.`,
        value: value,
      };
    }

    case "delete": {
      const note = (await obsidianService.getFileContent(
        effectiveFilePath,
        "json",
        context,
      )) as NoteJson;
      const frontmatter = note.frontmatter || {};
      if (key in frontmatter) {
        const patchOptions: PatchOptions = {
          operation: "replace",
          targetType: "frontmatter",
          target: key,
          contentType: "application/json",
        };
        await obsidianService.patchFile(
          effectiveFilePath,
          JSON.stringify(null),
          patchOptions,
          context,
        );
        return {
          success: true,
          message: `Successfully deleted key '${key}' from frontmatter.`,
        };
      }
      return {
        success: true,
        message: `Key '${key}' not found in frontmatter; no action taken.`,
      };
    }
  }
}
</file>

<file path="obsidianManageFrontmatterTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_manage_frontmatter' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianManageFrontmatterTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianManageFrontmatterLogic,
  ObsidianManageFrontmatterInput,
  ObsidianManageFrontmatterInputSchema,
  ObsidianManageFrontmatterOutputSchema,
  BaseObsidianManageFrontmatterInputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_manage_frontmatter";
const TOOL_DESCRIPTION =
  "Atomically manages a note's YAML frontmatter. Supports getting, setting (creating/updating), and deleting specific keys. Ideal for efficient metadata operations.";

/**
 * Registers the 'obsidian_manage_frontmatter' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianManageFrontmatterTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Manage Obsidian Frontmatter",
      description: TOOL_DESCRIPTION,
      inputSchema: BaseObsidianManageFrontmatterInputSchema.shape,
      outputSchema: ObsidianManageFrontmatterOutputSchema.shape,
      annotations: {
        readOnlyHint: false,
      },
    },
    async (
      params: ObsidianManageFrontmatterInput,
      callContext: Record<string, unknown>,
    ) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams =
          ObsidianManageFrontmatterInputSchema.parse(params);
        const result = await obsidianManageFrontmatterLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: result.message,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianManageTagsTool/index.ts">
/**
 * @fileoverview Barrel file for the obsidian_manage_tags tool.
 * @module src/mcp-server/tools/obsidianManageTagsTool/index
 */

export * from "./logic.js";
export * from "./registration.js";
</file>

<file path="obsidianManageTagsTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_manage_tags' tool.
 * @module src/mcp-server/tools/obsidianManageTagsTool/logic
 */

import { z } from "zod";
import { components } from "../../../services/obsidianRestAPI/generated-types.js";
import {
  ObsidianRestApiService,
  PatchOptions,
} from "../../../services/obsidianRestAPI/index.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { type RequestContext } from "../../../utils/index.js";
import { sanitization } from "../../../utils/security/sanitization.js";

type NoteJson = components["schemas"]["NoteJson"];

// 1. DEFINE the Zod input schema.
export const ObsidianManageTagsInputSchema = z.object({
  filePath: z
    .string()
    .min(1)
    .describe(
      "The vault-relative path to the target note (e.g., 'journal/2025-06-12.md').",
    ),
  operation: z
    .enum(["add", "remove", "list"])
    .describe(
      "The tag operation to perform: 'add' to include new tags, 'remove' to delete existing tags, or 'list' to view all current tags.",
    ),
  tags: z
    .array(z.string())
    .describe(
      "An array of tag names to be processed. The '#' prefix should be omitted (e.g., use 'project/active', not '#project/active').",
    ),
});

// 2. DEFINE the Zod response schema.
export const ObsidianManageTagsOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  currentTags: z.array(z.string()),
});

// 3. INFER and export TypeScript types.
export type ObsidianManageTagsInput = z.infer<
  typeof ObsidianManageTagsInputSchema
>;
export type ObsidianManageTagsOutput = z.infer<
  typeof ObsidianManageTagsOutputSchema
>;

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianManageTagsLogic(
  params: ObsidianManageTagsInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianManageTagsOutput> {
  const { filePath, operation, tags: inputTags } = params;
  const sanitizedTags = inputTags.map((t) => sanitization.sanitizeTagName(t));

  const effectiveFilePath = await resolveVaultPath(
    filePath,
    context,
    (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
    (dp, ctx) => obsidianService.listFiles(dp, ctx),
  );

  const initialNote = (await obsidianService.getFileContent(
    effectiveFilePath,
    "json",
    context,
  )) as NoteJson;
  const currentTags = initialNote.tags ?? [];

  if (operation === "list") {
    return {
      success: true,
      message: "Successfully listed all tags.",
      currentTags,
    };
  }

  const frontmatter = initialNote.frontmatter ?? {};
  const frontmatterTags = Array.isArray(frontmatter.tags)
    ? frontmatter.tags.map(String)
    : [];

  if (operation === "add") {
    const tagsToAdd = sanitizedTags.filter((t) => !frontmatterTags.includes(t));
    if (tagsToAdd.length === 0) {
      return {
        success: true,
        message:
          "No new tags to add; all provided tags already exist in frontmatter.",
        currentTags,
      };
    }
    const newTags = [...new Set([...frontmatterTags, ...tagsToAdd])];
    const patchOptions: PatchOptions = {
      operation: "replace",
      targetType: "frontmatter",
      target: "tags",
      createTargetIfMissing: true,
      contentType: "application/json",
    };
    await obsidianService.patchFile(
      effectiveFilePath,
      JSON.stringify(newTags),
      patchOptions,
      context,
    );
    const finalNote = (await obsidianService.getFileContent(
      effectiveFilePath,
      "json",
      context,
    )) as NoteJson;
    return {
      success: true,
      message: `Successfully added tags: ${tagsToAdd.join(", ")}.`,
      currentTags: finalNote.tags ?? [],
    };
  }

  if (operation === "remove") {
    const tagsToRemoveSet = new Set(sanitizedTags);
    const newTags = frontmatterTags.filter((t) => !tagsToRemoveSet.has(t));

    if (newTags.length === frontmatterTags.length) {
      return {
        success: true,
        message:
          "No tags to remove; none of the provided tags exist in frontmatter.",
        currentTags,
      };
    }

    const patchOptions: PatchOptions = {
      operation: "replace",
      targetType: "frontmatter",
      target: "tags",
      contentType: "application/json",
    };
    await obsidianService.patchFile(
      effectiveFilePath,
      JSON.stringify(newTags.length > 0 ? newTags : null),
      patchOptions,
      context,
    );

    const finalNote = (await obsidianService.getFileContent(
      effectiveFilePath,
      "json",
      context,
    )) as NoteJson;
    return {
      success: true,
      message: `Successfully removed tags from frontmatter.`,
      currentTags: finalNote.tags ?? [],
    };
  }

  throw new McpError(
    BaseErrorCode.VALIDATION_ERROR,
    `Invalid operation: ${operation}`,
  );
}
</file>

<file path="obsidianManageTagsTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_manage_tags' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianManageTagsTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  ObsidianManageTagsInput,
  ObsidianManageTagsInputSchema,
  obsidianManageTagsLogic,
  ObsidianManageTagsOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_manage_tags";
const TOOL_DESCRIPTION =
  "Manages tags for a specified note by modifying the `tags` key in the note's YAML frontmatter. Supports adding, removing, and listing tags.";

/**
 * Registers the 'obsidian_manage_tags' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianManageTagsTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Manage Obsidian Tags",
      description: TOOL_DESCRIPTION,
      inputSchema: ObsidianManageTagsInputSchema.shape,
      outputSchema: ObsidianManageTagsOutputSchema.shape,
      annotations: {
        readOnlyHint: false,
      },
    },
    async (
      params: ObsidianManageTagsInput,
      callContext: Record<string, unknown>,
    ) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianManageTagsInputSchema.parse(params);
        const result = await obsidianManageTagsLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: result.message,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianReadNoteTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_read_note' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_read_note tool module.
 * It re-exports the primary registration function (`registerObsidianReadNoteTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */
export { registerObsidianReadNoteTool } from "./registration.js";
</file>

<file path="obsidianReadNoteTool/logic.ts">
/**
 * @fileoverview Defines the core logic, schemas, and types for the obsidian_read_note tool.
 * @module src/mcp-server/tools/obsidianReadNoteTool/logic
 */

import { z } from "zod";
import {
  logger,
  type RequestContext,
  countTokens,
} from "../../../utils/index.js";
import { formatTimestamp } from "../../../services/obsidianRestAPI/utils/index.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/service.js";
import { components } from "../../../services/obsidianRestAPI/generated-types.js";
import { JsonValue, JsonValueSchema } from "../schemas/jsonSchema.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";

type NoteJson = components["schemas"]["NoteJson"];

const StatSchema = z.object({
  size: z.number(),
  mtime: z.number(),
  ctime: z.number(),
});

const NoteJsonSchema = z.object({
  content: z.string().optional(),
  frontmatter: z.record(z.string(), JsonValueSchema).optional(),
  stat: StatSchema,
  tags: z.array(z.string()),
  path: z.string(),
});

// 1. DEFINE the Zod input schema.
export const ObsidianReadNoteInputSchema = z.object({
  filePath: z
    .string()
    .min(1)
    .describe(
      'The vault-relative path to the target Obsidian note (e.g., "developer/github/tips.md"). Tries case-sensitive first, then case-insensitive fallback.',
    ),
  format: z
    .enum(["markdown", "json"])
    .default("markdown")
    .describe(
      "The desired format for the note's content. 'markdown' returns a raw string, while 'json' provides a structured object.",
    ),
  includeStat: z
    .boolean()
    .default(false)
    .describe(
      "If true and format is 'markdown', includes file stats in the response. Stats are always included for the 'json' format.",
    ),
});

// 2. DEFINE the Zod response schema.
const FormattedStatSchema = z.object({
  createdTime: z.string(),
  modifiedTime: z.string(),
  tokenCountEstimate: z.number(),
});

export const ObsidianReadNoteOutputSchema = z.object({
  content: z.union([z.string(), NoteJsonSchema]),
  stats: FormattedStatSchema.optional(),
});

// 3. INFER and export TypeScript types.
export type ObsidianReadNoteInput = z.infer<typeof ObsidianReadNoteInputSchema>;
export type ObsidianReadNoteOutput = z.infer<
  typeof ObsidianReadNoteOutputSchema
>;

type NoteStat = components["schemas"]["NoteJson"]["stat"];

async function createFormattedStatWithTokenCount(
  stat: NoteStat,
  content: string,
  context: RequestContext,
) {
  const tokenCount = await countTokens(content, context);
  return {
    createdTime: formatTimestamp(stat.ctime, context),
    modifiedTime: formatTimestamp(stat.mtime, context),
    tokenCountEstimate: tokenCount,
  };
}

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianReadNoteLogic(
  params: ObsidianReadNoteInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianReadNoteOutput> {
  const { filePath: originalFilePath, format, includeStat } = params;
  logger.debug(`Executing obsidianReadNoteLogic for: ${originalFilePath}`, {
    ...context,
    params,
  });

  const effectiveFilePath = await resolveVaultPath(
    originalFilePath,
    context,
    (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
    (dp, ctx) => obsidianService.listFiles(dp, ctx),
  );

  const noteJson = (await obsidianService.getFileContent(
    effectiveFilePath,
    "json",
    context,
  )) as NoteJson;

  const formattedStat = noteJson.stat
    ? await createFormattedStatWithTokenCount(
        noteJson.stat,
        noteJson.content ?? "",
        context,
      )
    : undefined;

  const response: ObsidianReadNoteOutput = {
    content:
      format === "json"
        ? ({
            ...noteJson,
            path: effectiveFilePath,
            frontmatter: noteJson.frontmatter as Record<string, JsonValue>,
          } as z.infer<typeof NoteJsonSchema>)
        : (noteJson.content ?? ""),
  };

  if (
    formattedStat &&
    (format === "json" || (format === "markdown" && includeStat))
  ) {
    response.stats = formattedStat;
  }

  return response;
}
</file>

<file path="obsidianReadNoteTool/registration.ts">
/**
 * @fileoverview Handles registration and error handling for the obsidian_read_note tool.
 * @module src/mcp-server/tools/obsidianReadNoteTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  ObsidianReadNoteInput,
  ObsidianReadNoteInputSchema,
  obsidianReadNoteLogic,
  ObsidianReadNoteOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_read_note";
const TOOL_DESCRIPTION =
  "Retrieves the content and metadata for a specific Obsidian note. Use this tool to read the contents of Obsidian notes. It tries an exact path match before falling back to a case-insensitive search. The `format` parameter controls the output ('markdown' or 'json'). Set `includeStat` to true to add file stats to the 'markdown' response; stats are always included with 'json'.";

/**
 * Registers the 'obsidian_read_note' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianReadNoteTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Read Obsidian Note",
      description: TOOL_DESCRIPTION,
      inputSchema: ObsidianReadNoteInputSchema.shape,
      outputSchema: ObsidianReadNoteOutputSchema.shape,
      annotations: {
        readOnlyHint: true,
      },
    },
    async (params: ObsidianReadNoteInput, callContext) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianReadNoteInputSchema.parse(params);
        const result = await obsidianReadNoteLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        let textOutput: string;
        if (typeof result.content === "string") {
          textOutput = result.content;
          if (result.stats) {
            textOutput += `\n\n---
**Created:** ${result.stats.createdTime}
**Modified:** ${result.stats.modifiedTime}
**Tokens:** ~${result.stats.tokenCountEstimate}`;
          }
        } else {
          textOutput = `Successfully read note: ${result.content.path}`;
        }

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: textOutput,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianSearchReplaceTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_search_replace' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_search_replace tool module.
 * It re-exports the primary registration function (`registerObsidianSearchReplaceTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */
export { registerObsidianSearchReplaceTool } from "./registration.js";
</file>

<file path="obsidianSearchReplaceTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_search_replace' tool.
 * @module src/mcp-server/tools/obsidianSearchReplaceTool/logic
 */

import { z } from "zod";
import {
  logger,
  type RequestContext,
  countTokens,
} from "../../../utils/index.js";
import { formatTimestamp } from "../../../services/obsidianRestAPI/utils/index.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/service.js";
import { components } from "../../../services/obsidianRestAPI/generated-types.js";

type NoteJson = components["schemas"]["NoteJson"];

// 1. DEFINE the Zod input schema.
const ReplacementBlockSchema = z.object({
  search: z.string().min(1),
  replace: z.string(),
});

export const BaseObsidianSearchReplaceInputSchema = z.object({
  targetType: z
    .enum(["filePath", "activeFile", "periodicNote"])
    .describe("The type of target note to perform the search and replace on."),
  targetIdentifier: z
    .string()
    .optional()
    .describe(
      "Identifier for the target note, required if targetType is 'filePath' or 'periodicNote'. For 'filePath', this is the vault-relative path. For 'periodicNote', it's the period (e.g., 'daily', 'weekly').",
    ),
  replacements: z
    .array(ReplacementBlockSchema)
    .min(1)
    .describe("An array of one or more search/replace pairs to apply."),
  useRegex: z
    .boolean()
    .default(false)
    .describe(
      "If true, the 'search' string is treated as a regular expression.",
    ),
  replaceAll: z
    .boolean()
    .default(true)
    .describe(
      "If true, all occurrences of the search string will be replaced. If false, only the first occurrence is replaced.",
    ),
  caseSensitive: z
    .boolean()
    .default(true)
    .describe("If true, the search will be case-sensitive."),
  flexibleWhitespace: z
    .boolean()
    .default(false)
    .describe(
      "If true, treats consecutive whitespace in the search string as a single space that can match multiple whitespace characters in the note. Cannot be used with useRegex.",
    ),
  wholeWord: z
    .boolean()
    .default(false)
    .describe(
      "If true, the search will only match whole words (bounded by non-word characters).",
    ),
  returnContent: z
    .boolean()
    .default(false)
    .describe(
      "If true, the final content of the note will be returned in the response.",
    ),
});

export const ObsidianSearchReplaceInputSchema =
  BaseObsidianSearchReplaceInputSchema.refine(
    (data) =>
      !(
        (data.targetType === "filePath" ||
          data.targetType === "periodicNote") &&
        !data.targetIdentifier
      ),
    {
      message: "targetIdentifier is required for filePath or periodicNote",
      path: ["targetIdentifier"],
    },
  ).refine((data) => !(data.flexibleWhitespace && data.useRegex), {
    message: "flexibleWhitespace cannot be true if useRegex is true",
    path: ["flexibleWhitespace", "useRegex"],
  });

// 2. DEFINE the Zod response schema.
const FormattedStatSchema = z.object({
  createdTime: z.string(),
  modifiedTime: z.string(),
  tokenCountEstimate: z.number(),
});

export const ObsidianSearchReplaceOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  totalReplacementsMade: z.number(),
  stats: FormattedStatSchema.optional(),
  finalContent: z.string().optional(),
});

// 3. INFER and export TypeScript types.
export type ObsidianSearchReplaceInput = z.infer<
  typeof ObsidianSearchReplaceInputSchema
>;
export type ObsidianSearchReplaceOutput = z.infer<
  typeof ObsidianSearchReplaceOutputSchema
>;

type NoteStat = components["schemas"]["NoteJson"]["stat"];

async function createFormattedStatWithTokenCount(
  stat: NoteStat,
  content: string,
  context: RequestContext,
) {
  const tokenCount = await countTokens(content, context);
  return {
    createdTime: formatTimestamp(stat.ctime, context),
    modifiedTime: formatTimestamp(stat.mtime, context),
    tokenCountEstimate: tokenCount,
  };
}

// Helper functions
async function getTargetNote(
  params: ObsidianSearchReplaceInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<{ effectiveFilePath?: string; content: string }> {
  const { targetType, targetIdentifier } = params;

  switch (targetType) {
    case "activeFile": {
      const content = (await obsidianService.getActiveFile(
        "markdown",
        context,
      )) as string;
      const effectiveFilePath =
        await obsidianService.getActiveFilePath(context);
      return { effectiveFilePath: effectiveFilePath ?? undefined, content };
    }
    case "periodicNote": {
      const note = (await obsidianService.getPeriodicNote(
        targetIdentifier as any,
        "json",
        context,
      )) as NoteJson;
      return { effectiveFilePath: note.path, content: note.content };
    }
    case "filePath": {
      const effectiveFilePath = await resolveVaultPath(
        targetIdentifier!,
        context,
        (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
        (dp, ctx) => obsidianService.listFiles(dp, ctx),
      );
      const content = (await obsidianService.getFileContent(
        effectiveFilePath,
        "markdown",
        context,
      )) as string;
      return { effectiveFilePath, content };
    }
  }
}

async function updateTargetNote(
  params: ObsidianSearchReplaceInput,
  effectiveFilePath: string | undefined,
  content: string,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
) {
  const { targetType, targetIdentifier } = params;
  switch (targetType) {
    case "filePath":
      await obsidianService.updateFileContent(
        effectiveFilePath!,
        content,
        context,
      );
      break;
    case "activeFile":
      await obsidianService.updateActiveFile(content, context);
      break;
    case "periodicNote":
      await obsidianService.updatePeriodicNote(
        targetIdentifier as any,
        content,
        context,
      );
      break;
  }
}

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianSearchReplaceLogic(
  params: ObsidianSearchReplaceInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianSearchReplaceOutput> {
  const {
    replacements,
    useRegex,
    replaceAll,
    caseSensitive,
    flexibleWhitespace,
    wholeWord,
    returnContent,
  } = params;

  const { effectiveFilePath, content: originalContent } = await getTargetNote(
    params,
    context,
    obsidianService,
  );

  let modifiedContent = originalContent;
  let totalReplacementsMade = 0;

  for (const rep of replacements) {
    let searchPattern: RegExp;
    let flags = replaceAll ? "g" : "";
    if (!caseSensitive) flags += "i";

    let searchStr = useRegex
      ? rep.search
      : rep.search.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    if (flexibleWhitespace) {
      searchStr = searchStr.replace(/\s+/g, "\\s+");
    }
    if (wholeWord) {
      searchStr = `\\b${searchStr}\\b`;
    }

    try {
      searchPattern = new RegExp(searchStr, flags);
    } catch (e) {
      throw new McpError(
        BaseErrorCode.VALIDATION_ERROR,
        `Invalid regex pattern constructed: ${searchStr}`,
      );
    }

    const matches = modifiedContent.match(searchPattern);
    const numMatches = matches ? matches.length : 0;

    if (numMatches > 0) {
      modifiedContent = modifiedContent.replace(searchPattern, rep.replace);
      totalReplacementsMade += numMatches;
    }
  }

  if (modifiedContent !== originalContent) {
    await updateTargetNote(
      params,
      effectiveFilePath,
      modifiedContent,
      context,
      obsidianService,
    );
  }

  const finalState = effectiveFilePath
    ? ((await obsidianService.getFileContent(
        effectiveFilePath,
        "json",
        context,
      )) as NoteJson)
    : null;

  const formattedStatResult = finalState?.stat
    ? await createFormattedStatWithTokenCount(
        finalState.stat,
        finalState.content ?? "",
        context,
      )
    : undefined;

  return {
    success: true,
    message: `Search/replace completed. ${totalReplacementsMade} replacements made.`,
    totalReplacementsMade,
    stats: formattedStatResult ?? undefined,
    finalContent: returnContent ? modifiedContent : undefined,
  };
}
</file>

<file path="obsidianSearchReplaceTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_search_replace' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianSearchReplaceTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianSearchReplaceLogic,
  ObsidianSearchReplaceInput,
  BaseObsidianSearchReplaceInputSchema,
  ObsidianSearchReplaceInputSchema,
  ObsidianSearchReplaceOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_search_replace";
const TOOL_DESCRIPTION =
  "Performs one or more search-and-replace operations within a target Obsidian note. Supports targeting by file path, active note, or periodic note. Allows for string or regex matching, case sensitivity, and more. Writes changes back to the vault.";

/**
 * Registers the 'obsidian_search_replace' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianSearchReplaceTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Search and Replace in Obsidian Note",
      description: TOOL_DESCRIPTION,
      inputSchema: BaseObsidianSearchReplaceInputSchema.shape,
      outputSchema: ObsidianSearchReplaceOutputSchema.shape,
      annotations: {
        readOnlyHint: false,
        destructiveHint: false, // It's not deleting, but it is modifying
      },
    },
    async (
      params: ObsidianSearchReplaceInput,
      callContext: Record<string, unknown>,
    ) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianSearchReplaceInputSchema.parse(params);
        const result = await obsidianSearchReplaceLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: result.message,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="obsidianUpdateNoteTool/index.ts">
/**
 * @fileoverview Barrel file for the 'obsidian_update_note' MCP tool.
 *
 * This file serves as the public entry point for the obsidian_update_note tool module.
 * It re-exports the primary registration function (`registerObsidianUpdateNoteTool`)
 * from the './registration.js' module. This pattern simplifies imports for consumers
 * of the tool, allowing them to import necessary components from a single location.
 *
 * Consumers (like the main server setup) should import the registration function
 * from this file to integrate the tool into the MCP server instance.
 */
export { registerObsidianUpdateNoteTool } from "./registration.js";
</file>

<file path="obsidianUpdateNoteTool/logic.ts">
/**
 * @fileoverview Core logic for the 'obsidian_update_note' tool.
 * @module src/mcp-server/tools/obsidianUpdateNoteTool/logic
 */

import path from "node:path";
import { z } from "zod";
import {
  logger,
  retryWithDelay,
  type RequestContext,
} from "../../../utils/index.js";
import { createFormattedStatWithTokenCount } from "../../../services/obsidianRestAPI/utils/formatting.js";
import { BaseErrorCode, McpError } from "../../../types-global/errors.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/service.js";
import { components } from "../../../services/obsidianRestAPI/generated-types.js";
import { resolveVaultPath } from "../../../services/obsidianRestAPI/utils/pathResolver.js";

type NoteJson = components["schemas"]["NoteJson"];

// 1. DEFINE the Zod input schema.
export const BaseObsidianUpdateNoteInputSchema = z.object({
  targetType: z
    .enum(["filePath", "activeFile", "periodicNote"])
    .describe("The type of target note to modify."),
  content: z.string().describe("The content to write to the note."),
  targetIdentifier: z
    .string()
    .optional()
    .describe(
      "Identifier for the target, required if targetType is 'filePath' or 'periodicNote'. For 'filePath', this is the vault-relative path. For 'periodicNote', it's the period (e.g., 'daily', 'weekly').",
    ),
  modificationType: z
    .literal("wholeFile")
    .describe("Specifies that the entire file will be modified."),
  wholeFileMode: z
    .enum(["append", "prepend", "overwrite"])
    .describe(
      "The mode of operation: 'append' to add to the end, 'prepend' to add to the beginning, or 'overwrite' to replace the entire content.",
    ),
  createIfNeeded: z
    .boolean()
    .default(true)
    .describe(
      "If true, a new note will be created if the target does not exist.",
    ),
  overwriteIfExists: z
    .boolean()
    .default(false)
    .describe(
      "If true, an existing note will be overwritten. Use with caution. Only applicable when wholeFileMode is 'overwrite'.",
    ),
  returnContent: z
    .boolean()
    .default(false)
    .describe(
      "If true, the final content of the note will be returned in the response.",
    ),
});

export const ObsidianUpdateNoteInputSchema =
  BaseObsidianUpdateNoteInputSchema.refine(
    (data) =>
      !(
        (data.targetType === "filePath" ||
          data.targetType === "periodicNote") &&
        !data.targetIdentifier
      ),
    {
      message: "targetIdentifier is required for filePath or periodicNote",
      path: ["targetIdentifier"],
    },
  );

// 2. DEFINE the Zod response schema.
const FormattedStatSchema = z.object({
  createdTime: z.string(),
  modifiedTime: z.string(),
  tokenCountEstimate: z.number(),
});

export const ObsidianUpdateNoteOutputSchema = z.object({
  success: z.boolean(),
  message: z.string(),
  stats: FormattedStatSchema.optional(),
  finalContent: z.string().optional(),
});

// 3. INFER and export TypeScript types.
export type ObsidianUpdateNoteInput = z.infer<
  typeof ObsidianUpdateNoteInputSchema
>;
export type ObsidianUpdateNoteOutput = z.infer<
  typeof ObsidianUpdateNoteOutputSchema
>;

// Helper function
async function getTargetNote(
  targetType: string,
  targetIdentifier: string | undefined,
  obsidianService: ObsidianRestApiService,
  context: RequestContext,
): Promise<NoteJson | null> {
  try {
    if (targetType === "filePath" && targetIdentifier) {
      return (await obsidianService.getFileContent(
        targetIdentifier,
        "json",
        context,
      )) as NoteJson;
    }
    if (targetType === "activeFile") {
      return (await obsidianService.getActiveFile("json", context)) as NoteJson;
    }
    if (targetType === "periodicNote" && targetIdentifier) {
      return (await obsidianService.getPeriodicNote(
        targetIdentifier as any,
        "json",
        context,
      )) as NoteJson;
    }
    return null;
  } catch (error) {
    if (error instanceof McpError && error.code === BaseErrorCode.NOT_FOUND) {
      return null;
    }
    throw error;
  }
}

/**
 * 4. IMPLEMENT the core logic function.
 * @throws {McpError} If the logic encounters an unrecoverable issue.
 */
export async function obsidianUpdateNoteLogic(
  params: ObsidianUpdateNoteInput,
  context: RequestContext,
  obsidianService: ObsidianRestApiService,
): Promise<ObsidianUpdateNoteOutput> {
  const {
    targetType,
    targetIdentifier,
    content,
    wholeFileMode,
    createIfNeeded,
    overwriteIfExists,
    returnContent,
  } = params;

  let effectiveFilePath = targetIdentifier;
  if (targetType === "filePath" && targetIdentifier) {
    try {
      effectiveFilePath = await resolveVaultPath(
        targetIdentifier,
        context,
        (fp, ctx) => obsidianService.getFileMetadata(fp, ctx),
        (dp, ctx) => obsidianService.listFiles(dp, ctx),
      );
    } catch (error) {
      if (
        error instanceof McpError &&
        error.code === BaseErrorCode.NOT_FOUND &&
        createIfNeeded
      ) {
        // If the file doesn't exist and we're allowed to create it, we use the original path.
        effectiveFilePath = targetIdentifier;
      } else {
        // Otherwise, re-throw the error.
        throw error;
      }
    }
  }

  const existingNote = await getTargetNote(
    targetType,
    effectiveFilePath,
    obsidianService,
    context,
  );

  if (!existingNote && !createIfNeeded) {
    throw new McpError(
      BaseErrorCode.NOT_FOUND,
      `Target ${targetType} '${
        targetIdentifier ?? "(active)"
      }' not found, and 'createIfNeeded' is set to false.`,
    );
  }

  if (wholeFileMode === "overwrite" && existingNote && !overwriteIfExists) {
    throw new McpError(
      BaseErrorCode.CONFLICT,
      `Target ${targetType} '${
        targetIdentifier ?? "(active)"
      }' exists, and 'overwriteIfExists' is set to false.`,
    );
  }

  let finalContent = content;
  if (
    (wholeFileMode === "append" || wholeFileMode === "prepend") &&
    existingNote
  ) {
    const oldContent = existingNote.content ?? "";
    finalContent =
      wholeFileMode === "prepend" ? content + oldContent : oldContent + content;
  }

  // Perform the write operation
  try {
    switch (targetType) {
      case "filePath":
        await obsidianService.updateFileContent(
          effectiveFilePath!,
          finalContent,
          context,
        );
        break;
      case "activeFile":
        if (!existingNote) {
          throw new McpError(
            BaseErrorCode.VALIDATION_ERROR,
            "Cannot create a new note when targetType is 'activeFile'. The file must already be open in Obsidian.",
          );
        }
        await obsidianService.updateActiveFile(finalContent, context);
        break;
      case "periodicNote":
        await obsidianService.updatePeriodicNote(
          targetIdentifier as any,
          finalContent,
          context,
        );
        break;
    }
  } catch (error) {
    if (
      error instanceof McpError &&
      error.code === BaseErrorCode.NOT_FOUND &&
      targetType === "filePath" &&
      targetIdentifier &&
      targetIdentifier.includes("/")
    ) {
      const parentDir = path.posix.dirname(targetIdentifier);
      throw new McpError(
        BaseErrorCode.VALIDATION_ERROR,
        `Failed to create note. The parent directory '${parentDir}' may not exist. Please create it in Obsidian first.`,
      );
    }
    throw error;
  }

  // Retry fetching the final state to account for file system delays
  const finalState = await retryWithDelay(
    () => getTargetNote(targetType, targetIdentifier, obsidianService, context),
    {
      operationName: "getFinalNoteState",
      context,
      maxRetries: 3,
      delayMs: 500,
      shouldRetry: (err: unknown) =>
        err instanceof McpError && err.code === BaseErrorCode.NOT_FOUND,
    },
  );

  if (!finalState) {
    throw new McpError(
      BaseErrorCode.INTERNAL_ERROR,
      "Failed to retrieve note state after update operation.",
    );
  }

  const stats = finalState.stat
    ? await createFormattedStatWithTokenCount(
        finalState.stat,
        finalState.content ?? "",
        context,
      )
    : undefined;

  return {
    success: true,
    message: `Successfully updated note.`,
    stats: stats ?? undefined,
    finalContent: returnContent ? finalState.content : undefined,
  };
}
</file>

<file path="obsidianUpdateNoteTool/registration.ts">
/**
 * @fileoverview Registers the 'obsidian_update_note' tool with the MCP server.
 * @module src/mcp-server/tools/obsidianUpdateNoteTool/registration
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { ObsidianRestApiService } from "../../../services/obsidianRestAPI/index.js";
import { McpError } from "../../../types-global/errors.js";
import {
  ErrorHandler,
  logger,
  requestContextService,
} from "../../../utils/index.js";
import {
  obsidianUpdateNoteLogic,
  ObsidianUpdateNoteInput,
  BaseObsidianUpdateNoteInputSchema,
  ObsidianUpdateNoteInputSchema,
  ObsidianUpdateNoteOutputSchema,
} from "./logic.js";

const TOOL_NAME = "obsidian_update_note";
const TOOL_DESCRIPTION =
  "Modifies Obsidian notes using whole-file operations: 'append', 'prepend', or 'overwrite'. Supports targeting by file path, active note, or periodic note. Options control creation and overwrite behavior.";

/**
 * Registers the 'obsidian_update_note' tool with the MCP server.
 * @param server The MCP server instance.
 * @param obsidianService An instance of the ObsidianRestApiService.
 */
export const registerObsidianUpdateNoteTool = async (
  server: McpServer,
  obsidianService: ObsidianRestApiService,
): Promise<void> => {
  server.registerTool(
    TOOL_NAME,
    {
      title: "Update Obsidian Note",
      description: TOOL_DESCRIPTION,
      inputSchema: BaseObsidianUpdateNoteInputSchema.shape,
      outputSchema: ObsidianUpdateNoteOutputSchema.shape,
      annotations: {
        readOnlyHint: false,
      },
    },
    async (
      params: ObsidianUpdateNoteInput,
      callContext: Record<string, unknown>,
    ) => {
      const handlerContext = requestContextService.createRequestContext({
        toolName: TOOL_NAME,
        parentContext: callContext,
      });

      try {
        const validatedParams = ObsidianUpdateNoteInputSchema.parse(params);
        const result = await obsidianUpdateNoteLogic(
          validatedParams,
          handlerContext,
          obsidianService,
        );

        return {
          structuredContent: result,
          content: [
            {
              type: "text",
              text: result.message,
            },
          ],
        };
      } catch (error) {
        logger.error(`Error in ${TOOL_NAME} handler`, {
          error,
          ...handlerContext,
        });
        const mcpError = ErrorHandler.handleError(error, {
          operation: `tool:${TOOL_NAME}`,
          context: handlerContext,
          input: params,
        }) as McpError;

        return {
          isError: true,
          content: [{ type: "text", text: mcpError.message }],
          structuredContent: {
            code: mcpError.code,
            message: mcpError.message,
            details: mcpError.details,
          },
        };
      }
    },
  );
  logger.info(`Tool '${TOOL_NAME}' registered successfully.`);
};
</file>

<file path="schemas/jsonSchema.ts">
/**
 * @fileoverview Defines a self-referencing Zod schema for validating JSON-compatible values.
 * @module src/mcp-server/tools/schemas/jsonSchema
 */

import { z } from "zod";

/**
 * @description
 * Defines a self-referencing Zod schema for validating JSON-compatible values.
 * This is necessary because standard JSON can have nested structures (objects within objects, arrays of objects, etc.),
 * and `z.any()` is too permissive for strict type validation required by some systems.
 *
 * - `type JsonValue`: A TypeScript type alias that mirrors the structure of a JSON value. It can be a primitive
 *   (string, number, boolean, null, undefined) or a recursive structure (an object with string keys and JsonValue values,
 *   or an array of JsonValues).
 *
 * - `const JsonValueSchema`: The Zod schema implementation.
 *   - `z.lazy()`: This is the key to handling recursion. Zod schemas are typically defined statically, but for a type
 *     that refers to itself (like a nested JSON object), we need to defer its definition. `z.lazy()` allows the
 *     schema to be evaluated at runtime, breaking the infinite loop that would otherwise occur.
 *   - `z.union([...])`: Defines that a valid `JsonValue` can be one of several types.
 *   - `z.record(z.string(), z.lazy(() => JsonValueSchema))`: This defines an object with string keys and values that
 *     must also conform to the `JsonValueSchema`. Another `z.lazy()` is used here for the recursive definition.
 *   - `z.array(z.lazy(() => JsonValueSchema))`: This defines an array where each element must also conform to the
 *     `JsonValueSchema`, again using `z.lazy()` for recursion.
 */
export type JsonValue =
  | string
  | number
  | boolean
  | null
  | undefined
  | { [x: string]: JsonValue }
  | Array<JsonValue>;

export const JsonValueSchema: z.ZodType<JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.null(),
    z.undefined(),
    z.record(
      z.string(),
      z.lazy(() => JsonValueSchema),
    ),
    z.array(z.lazy(() => JsonValueSchema)),
  ]),
);
</file>

</repository_files>


---